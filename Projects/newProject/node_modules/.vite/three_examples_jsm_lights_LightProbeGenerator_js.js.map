{
  "version": 3,
  "sources": ["../../../../Library/PackageCache/com.needle.engine@2.7.3-pre/package~/node_modules/three/examples/jsm/lights/LightProbeGenerator.js"],
  "sourcesContent": ["import {\n\tColor,\n\tLightProbe,\n\tLinearEncoding,\n\tSphericalHarmonics3,\n\tVector3,\n\tsRGBEncoding\n} from 'three';\n\nclass LightProbeGenerator {\n\n\t// https://www.ppsloan.org/publications/StupidSH36.pdf\n\tstatic fromCubeTexture( cubeTexture ) {\n\n\t\tlet totalWeight = 0;\n\n\t\tconst coord = new Vector3();\n\n\t\tconst dir = new Vector3();\n\n\t\tconst color = new Color();\n\n\t\tconst shBasis = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];\n\n\t\tconst sh = new SphericalHarmonics3();\n\t\tconst shCoefficients = sh.coefficients;\n\n\t\tfor ( let faceIndex = 0; faceIndex < 6; faceIndex ++ ) {\n\n\t\t\tconst image = cubeTexture.image[ faceIndex ];\n\n\t\t\tconst width = image.width;\n\t\t\tconst height = image.height;\n\n\t\t\tconst canvas = document.createElement( 'canvas' );\n\n\t\t\tcanvas.width = width;\n\t\t\tcanvas.height = height;\n\n\t\t\tconst context = canvas.getContext( '2d' );\n\n\t\t\tcontext.drawImage( image, 0, 0, width, height );\n\n\t\t\tconst imageData = context.getImageData( 0, 0, width, height );\n\n\t\t\tconst data = imageData.data;\n\n\t\t\tconst imageWidth = imageData.width; // assumed to be square\n\n\t\t\tconst pixelSize = 2 / imageWidth;\n\n\t\t\tfor ( let i = 0, il = data.length; i < il; i += 4 ) { // RGBA assumed\n\n\t\t\t\t// pixel color\n\t\t\t\tcolor.setRGB( data[ i ] / 255, data[ i + 1 ] / 255, data[ i + 2 ] / 255 );\n\n\t\t\t\t// convert to linear color space\n\t\t\t\tconvertColorToLinear( color, cubeTexture.encoding );\n\n\t\t\t\t// pixel coordinate on unit cube\n\n\t\t\t\tconst pixelIndex = i / 4;\n\n\t\t\t\tconst col = - 1 + ( pixelIndex % imageWidth + 0.5 ) * pixelSize;\n\n\t\t\t\tconst row = 1 - ( Math.floor( pixelIndex / imageWidth ) + 0.5 ) * pixelSize;\n\n\t\t\t\tswitch ( faceIndex ) {\n\n\t\t\t\t\tcase 0: coord.set( - 1, row, - col ); break;\n\n\t\t\t\t\tcase 1: coord.set( 1, row, col ); break;\n\n\t\t\t\t\tcase 2: coord.set( - col, 1, - row ); break;\n\n\t\t\t\t\tcase 3: coord.set( - col, - 1, row ); break;\n\n\t\t\t\t\tcase 4: coord.set( - col, row, 1 ); break;\n\n\t\t\t\t\tcase 5: coord.set( col, row, - 1 ); break;\n\n\t\t\t\t}\n\n\t\t\t\t// weight assigned to this pixel\n\n\t\t\t\tconst lengthSq = coord.lengthSq();\n\n\t\t\t\tconst weight = 4 / ( Math.sqrt( lengthSq ) * lengthSq );\n\n\t\t\t\ttotalWeight += weight;\n\n\t\t\t\t// direction vector to this pixel\n\t\t\t\tdir.copy( coord ).normalize();\n\n\t\t\t\t// evaluate SH basis functions in direction dir\n\t\t\t\tSphericalHarmonics3.getBasisAt( dir, shBasis );\n\n\t\t\t\t// accummuulate\n\t\t\t\tfor ( let j = 0; j < 9; j ++ ) {\n\n\t\t\t\t\tshCoefficients[ j ].x += shBasis[ j ] * color.r * weight;\n\t\t\t\t\tshCoefficients[ j ].y += shBasis[ j ] * color.g * weight;\n\t\t\t\t\tshCoefficients[ j ].z += shBasis[ j ] * color.b * weight;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// normalize\n\t\tconst norm = ( 4 * Math.PI ) / totalWeight;\n\n\t\tfor ( let j = 0; j < 9; j ++ ) {\n\n\t\t\tshCoefficients[ j ].x *= norm;\n\t\t\tshCoefficients[ j ].y *= norm;\n\t\t\tshCoefficients[ j ].z *= norm;\n\n\t\t}\n\n\t\treturn new LightProbe( sh );\n\n\t}\n\n\tstatic fromCubeRenderTarget( renderer, cubeRenderTarget ) {\n\n\t\t// The renderTarget must be set to RGBA in order to make readRenderTargetPixels works\n\t\tlet totalWeight = 0;\n\n\t\tconst coord = new Vector3();\n\n\t\tconst dir = new Vector3();\n\n\t\tconst color = new Color();\n\n\t\tconst shBasis = [ 0, 0, 0, 0, 0, 0, 0, 0, 0 ];\n\n\t\tconst sh = new SphericalHarmonics3();\n\t\tconst shCoefficients = sh.coefficients;\n\n\t\tfor ( let faceIndex = 0; faceIndex < 6; faceIndex ++ ) {\n\n\t\t\tconst imageWidth = cubeRenderTarget.width; // assumed to be square\n\t\t\tconst data = new Uint8Array( imageWidth * imageWidth * 4 );\n\t\t\trenderer.readRenderTargetPixels( cubeRenderTarget, 0, 0, imageWidth, imageWidth, data, faceIndex );\n\n\t\t\tconst pixelSize = 2 / imageWidth;\n\n\t\t\tfor ( let i = 0, il = data.length; i < il; i += 4 ) { // RGBA assumed\n\n\t\t\t\t// pixel color\n\t\t\t\tcolor.setRGB( data[ i ] / 255, data[ i + 1 ] / 255, data[ i + 2 ] / 255 );\n\n\t\t\t\t// convert to linear color space\n\t\t\t\tconvertColorToLinear( color, cubeRenderTarget.texture.encoding );\n\n\t\t\t\t// pixel coordinate on unit cube\n\n\t\t\t\tconst pixelIndex = i / 4;\n\n\t\t\t\tconst col = - 1 + ( pixelIndex % imageWidth + 0.5 ) * pixelSize;\n\n\t\t\t\tconst row = 1 - ( Math.floor( pixelIndex / imageWidth ) + 0.5 ) * pixelSize;\n\n\t\t\t\tswitch ( faceIndex ) {\n\n\t\t\t\t\tcase 0: coord.set( 1, row, - col ); break;\n\n\t\t\t\t\tcase 1: coord.set( - 1, row, col ); break;\n\n\t\t\t\t\tcase 2: coord.set( col, 1, - row ); break;\n\n\t\t\t\t\tcase 3: coord.set( col, - 1, row ); break;\n\n\t\t\t\t\tcase 4: coord.set( col, row, 1 ); break;\n\n\t\t\t\t\tcase 5: coord.set( - col, row, - 1 ); break;\n\n\t\t\t\t}\n\n\t\t\t\t// weight assigned to this pixel\n\n\t\t\t\tconst lengthSq = coord.lengthSq();\n\n\t\t\t\tconst weight = 4 / ( Math.sqrt( lengthSq ) * lengthSq );\n\n\t\t\t\ttotalWeight += weight;\n\n\t\t\t\t// direction vector to this pixel\n\t\t\t\tdir.copy( coord ).normalize();\n\n\t\t\t\t// evaluate SH basis functions in direction dir\n\t\t\t\tSphericalHarmonics3.getBasisAt( dir, shBasis );\n\n\t\t\t\t// accummuulate\n\t\t\t\tfor ( let j = 0; j < 9; j ++ ) {\n\n\t\t\t\t\tshCoefficients[ j ].x += shBasis[ j ] * color.r * weight;\n\t\t\t\t\tshCoefficients[ j ].y += shBasis[ j ] * color.g * weight;\n\t\t\t\t\tshCoefficients[ j ].z += shBasis[ j ] * color.b * weight;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// normalize\n\t\tconst norm = ( 4 * Math.PI ) / totalWeight;\n\n\t\tfor ( let j = 0; j < 9; j ++ ) {\n\n\t\t\tshCoefficients[ j ].x *= norm;\n\t\t\tshCoefficients[ j ].y *= norm;\n\t\t\tshCoefficients[ j ].z *= norm;\n\n\t\t}\n\n\t\treturn new LightProbe( sh );\n\n\t}\n\n}\n\nfunction convertColorToLinear( color, encoding ) {\n\n\tswitch ( encoding ) {\n\n\t\tcase sRGBEncoding:\n\n\t\t\tcolor.convertSRGBToLinear();\n\t\t\tbreak;\n\n\t\tcase LinearEncoding:\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tconsole.warn( 'WARNING: LightProbeGenerator convertColorToLinear() encountered an unsupported encoding.' );\n\t\t\tbreak;\n\n\t}\n\n\treturn color;\n\n}\n\nexport { LightProbeGenerator };\n"],
  "mappings": "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",
  "names": []
}
