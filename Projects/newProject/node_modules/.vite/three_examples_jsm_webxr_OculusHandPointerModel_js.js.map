{
  "version": 3,
  "sources": ["../../../../Library/PackageCache/com.needle.engine@2.7.3-pre/package~/node_modules/three/examples/jsm/webxr/OculusHandPointerModel.js"],
  "sourcesContent": ["import * as THREE from 'three';\n\nconst PINCH_MAX = 0.05;\nconst PINCH_THRESHOLD = 0.02;\nconst PINCH_MIN = 0.01;\nconst POINTER_ADVANCE_MAX = 0.02;\nconst POINTER_OPACITY_MAX = 1;\nconst POINTER_OPACITY_MIN = 0.4;\nconst POINTER_FRONT_RADIUS = 0.002;\nconst POINTER_REAR_RADIUS = 0.01;\nconst POINTER_REAR_RADIUS_MIN = 0.003;\nconst POINTER_LENGTH = 0.035;\nconst POINTER_SEGMENTS = 16;\nconst POINTER_RINGS = 12;\nconst POINTER_HEMISPHERE_ANGLE = 110;\nconst YAXIS = new THREE.Vector3( 0, 1, 0 );\nconst ZAXIS = new THREE.Vector3( 0, 0, 1 );\n\nconst CURSOR_RADIUS = 0.02;\nconst CURSOR_MAX_DISTANCE = 1.5;\n\nclass OculusHandPointerModel extends THREE.Object3D {\n\n\tconstructor( hand, controller ) {\n\n\t\tsuper();\n\n\t\tthis.hand = hand;\n\t\tthis.controller = controller;\n\t\tthis.motionController = null;\n\t\tthis.envMap = null;\n\n\t\tthis.mesh = null;\n\n\t\tthis.pointerGeometry = null;\n\t\tthis.pointerMesh = null;\n\t\tthis.pointerObject = null;\n\n\t\tthis.pinched = false;\n\t\tthis.attached = false;\n\n\t\tthis.cursorObject = null;\n\n\t\tthis.raycaster = null;\n\n\t\thand.addEventListener( 'connected', ( event ) => {\n\n\t\t\tconst xrInputSource = event.data;\n\n\t\t\tif ( xrInputSource.hand ) {\n\n\t\t\t\tthis.visible = true;\n\t\t\t\tthis.xrInputSource = xrInputSource;\n\n\t\t\t\tif ( this.pointerObject === null ) {\n\n\t\t\t\t\tthis.createPointer();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} );\n\n\t}\n\n\t_drawVerticesRing( vertices, baseVector, ringIndex ) {\n\n\t\tconst segmentVector = baseVector.clone();\n\t\tfor ( let i = 0; i < POINTER_SEGMENTS; i ++ ) {\n\n\t\t\tsegmentVector.applyAxisAngle( ZAXIS, ( Math.PI * 2 ) / POINTER_SEGMENTS );\n\t\t\tconst vid = ringIndex * POINTER_SEGMENTS + i;\n\t\t\tvertices[ 3 * vid ] = segmentVector.x;\n\t\t\tvertices[ 3 * vid + 1 ] = segmentVector.y;\n\t\t\tvertices[ 3 * vid + 2 ] = segmentVector.z;\n\n\t\t}\n\n\t}\n\n\t_updatePointerVertices( rearRadius ) {\n\n\t\tconst vertices = this.pointerGeometry.attributes.position.array;\n\t\t// first ring for front face\n\t\tconst frontFaceBase = new THREE.Vector3(\n\t\t\tPOINTER_FRONT_RADIUS,\n\t\t\t0,\n\t\t\t- 1 * ( POINTER_LENGTH - rearRadius )\n\t\t);\n\t\tthis._drawVerticesRing( vertices, frontFaceBase, 0 );\n\n\t\t// rings for rear hemisphere\n\t\tconst rearBase = new THREE.Vector3(\n\t\t\tMath.sin( ( Math.PI * POINTER_HEMISPHERE_ANGLE ) / 180 ) * rearRadius,\n\t\t\tMath.cos( ( Math.PI * POINTER_HEMISPHERE_ANGLE ) / 180 ) * rearRadius,\n\t\t\t0\n\t\t);\n\t\tfor ( let i = 0; i < POINTER_RINGS; i ++ ) {\n\n\t\t\tthis._drawVerticesRing( vertices, rearBase, i + 1 );\n\t\t\trearBase.applyAxisAngle(\n\t\t\t\tYAXIS,\n\t\t\t\t( Math.PI * POINTER_HEMISPHERE_ANGLE ) / 180 / ( POINTER_RINGS * - 2 )\n\t\t\t);\n\n\t\t}\n\n\t\t// front and rear face center vertices\n\t\tconst frontCenterIndex = POINTER_SEGMENTS * ( 1 + POINTER_RINGS );\n\t\tconst rearCenterIndex = POINTER_SEGMENTS * ( 1 + POINTER_RINGS ) + 1;\n\t\tconst frontCenter = new THREE.Vector3(\n\t\t\t0,\n\t\t\t0,\n\t\t\t- 1 * ( POINTER_LENGTH - rearRadius )\n\t\t);\n\t\tvertices[ frontCenterIndex * 3 ] = frontCenter.x;\n\t\tvertices[ frontCenterIndex * 3 + 1 ] = frontCenter.y;\n\t\tvertices[ frontCenterIndex * 3 + 2 ] = frontCenter.z;\n\t\tconst rearCenter = new THREE.Vector3( 0, 0, rearRadius );\n\t\tvertices[ rearCenterIndex * 3 ] = rearCenter.x;\n\t\tvertices[ rearCenterIndex * 3 + 1 ] = rearCenter.y;\n\t\tvertices[ rearCenterIndex * 3 + 2 ] = rearCenter.z;\n\n\t\tthis.pointerGeometry.setAttribute(\n\t\t\t'position',\n\t\t\tnew THREE.Float32BufferAttribute( vertices, 3 )\n\t\t);\n\t\t// verticesNeedUpdate = true;\n\n\t}\n\n\tcreatePointer() {\n\n\t\tlet i, j;\n\t\tconst vertices = new Array(\n\t\t\t( ( POINTER_RINGS + 1 ) * POINTER_SEGMENTS + 2 ) * 3\n\t\t).fill( 0 );\n\t\t// const vertices = [];\n\t\tconst indices = [];\n\t\tthis.pointerGeometry = new THREE.BufferGeometry();\n\n\t\tthis.pointerGeometry.setAttribute(\n\t\t\t'position',\n\t\t\tnew THREE.Float32BufferAttribute( vertices, 3 )\n\t\t);\n\n\t\tthis._updatePointerVertices( POINTER_REAR_RADIUS );\n\n\t\t// construct faces to connect rings\n\t\tfor ( i = 0; i < POINTER_RINGS; i ++ ) {\n\n\t\t\tfor ( j = 0; j < POINTER_SEGMENTS - 1; j ++ ) {\n\n\t\t\t\tindices.push(\n\t\t\t\t\ti * POINTER_SEGMENTS + j,\n\t\t\t\t\ti * POINTER_SEGMENTS + j + 1,\n\t\t\t\t\t( i + 1 ) * POINTER_SEGMENTS + j\n\t\t\t\t);\n\t\t\t\tindices.push(\n\t\t\t\t\ti * POINTER_SEGMENTS + j + 1,\n\t\t\t\t\t( i + 1 ) * POINTER_SEGMENTS + j + 1,\n\t\t\t\t\t( i + 1 ) * POINTER_SEGMENTS + j\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\tindices.push(\n\t\t\t\t( i + 1 ) * POINTER_SEGMENTS - 1,\n\t\t\t\ti * POINTER_SEGMENTS,\n\t\t\t\t( i + 2 ) * POINTER_SEGMENTS - 1\n\t\t\t);\n\t\t\tindices.push(\n\t\t\t\ti * POINTER_SEGMENTS,\n\t\t\t\t( i + 1 ) * POINTER_SEGMENTS,\n\t\t\t\t( i + 2 ) * POINTER_SEGMENTS - 1\n\t\t\t);\n\n\t\t}\n\n\t\t// construct front and rear face\n\t\tconst frontCenterIndex = POINTER_SEGMENTS * ( 1 + POINTER_RINGS );\n\t\tconst rearCenterIndex = POINTER_SEGMENTS * ( 1 + POINTER_RINGS ) + 1;\n\n\t\tfor ( i = 0; i < POINTER_SEGMENTS - 1; i ++ ) {\n\n\t\t\tindices.push( frontCenterIndex, i + 1, i );\n\t\t\tindices.push(\n\t\t\t\trearCenterIndex,\n\t\t\t\ti + POINTER_SEGMENTS * POINTER_RINGS,\n\t\t\t\ti + POINTER_SEGMENTS * POINTER_RINGS + 1\n\t\t\t);\n\n\t\t}\n\n\t\tindices.push( frontCenterIndex, 0, POINTER_SEGMENTS - 1 );\n\t\tindices.push(\n\t\t\trearCenterIndex,\n\t\t\tPOINTER_SEGMENTS * ( POINTER_RINGS + 1 ) - 1,\n\t\t\tPOINTER_SEGMENTS * POINTER_RINGS\n\t\t);\n\n\t\tconst material = new THREE.MeshBasicMaterial();\n\t\tmaterial.transparent = true;\n\t\tmaterial.opacity = POINTER_OPACITY_MIN;\n\n\t\tthis.pointerGeometry.setIndex( indices );\n\n\t\tthis.pointerMesh = new THREE.Mesh( this.pointerGeometry, material );\n\n\t\tthis.pointerMesh.position.set( 0, 0, - 1 * POINTER_REAR_RADIUS );\n\t\tthis.pointerObject = new THREE.Object3D();\n\t\tthis.pointerObject.add( this.pointerMesh );\n\n\t\tthis.raycaster = new THREE.Raycaster();\n\n\t\t// create cursor\n\t\tconst cursorGeometry = new THREE.SphereGeometry( CURSOR_RADIUS, 10, 10 );\n\t\tconst cursorMaterial = new THREE.MeshBasicMaterial();\n\t\tcursorMaterial.transparent = true;\n\t\tcursorMaterial.opacity = POINTER_OPACITY_MIN;\n\n\t\tthis.cursorObject = new THREE.Mesh( cursorGeometry, cursorMaterial );\n\t\tthis.pointerObject.add( this.cursorObject );\n\n\t\tthis.add( this.pointerObject );\n\t\tthis.pointerObject.layers.mask = this.layers.mask;\n\t\tthis.pointerMesh.layers.mask = this.layers.mask;\n\n\t}\n\n\t_updateRaycaster() {\n\n\t\tif ( this.raycaster ) {\n\n\t\t\tconst pointerMatrix = this.pointerObject.matrixWorld;\n\t\t\tconst tempMatrix = new THREE.Matrix4();\n\t\t\ttempMatrix.identity().extractRotation( pointerMatrix );\n\t\t\tthis.raycaster.ray.origin.setFromMatrixPosition( pointerMatrix );\n\t\t\tthis.raycaster.ray.direction.set( 0, 0, - 1 ).applyMatrix4( tempMatrix );\n\n\t\t}\n\n\t}\n\n\t_updatePointer() {\n\n\t\tthis.pointerObject.visible = this.controller.visible;\n\t\tconst indexTip = this.hand.joints[ 'index-finger-tip' ];\n\t\tconst thumbTip = this.hand.joints[ 'thumb-tip' ];\n\t\tconst distance = indexTip.position.distanceTo( thumbTip.position );\n\t\tconst position = indexTip.position\n\t\t\t.clone()\n\t\t\t.add( thumbTip.position )\n\t\t\t.multiplyScalar( 0.5 );\n\t\tthis.pointerObject.position.copy( position );\n\t\tthis.pointerObject.quaternion.copy( this.controller.quaternion );\n\n\t\tthis.pinched = distance <= PINCH_THRESHOLD;\n\n\t\tconst pinchScale = ( distance - PINCH_MIN ) / ( PINCH_MAX - PINCH_MIN );\n\t\tconst focusScale = ( distance - PINCH_MIN ) / ( PINCH_THRESHOLD - PINCH_MIN );\n\t\tif ( pinchScale > 1 ) {\n\n\t\t\tthis._updatePointerVertices( POINTER_REAR_RADIUS );\n\t\t\tthis.pointerMesh.position.set( 0, 0, - 1 * POINTER_REAR_RADIUS );\n\t\t\tthis.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n\n\t\t} else if ( pinchScale > 0 ) {\n\n\t\t\tconst rearRadius =\n        ( POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN ) * pinchScale +\n        POINTER_REAR_RADIUS_MIN;\n\t\t\tthis._updatePointerVertices( rearRadius );\n\t\t\tif ( focusScale < 1 ) {\n\n\t\t\t\tthis.pointerMesh.position.set(\n\t\t\t\t\t0,\n\t\t\t\t\t0,\n\t\t\t\t\t- 1 * rearRadius - ( 1 - focusScale ) * POINTER_ADVANCE_MAX\n\t\t\t\t);\n\t\t\t\tthis.pointerMesh.material.opacity =\n          POINTER_OPACITY_MIN +\n          ( 1 - focusScale ) * ( POINTER_OPACITY_MAX - POINTER_OPACITY_MIN );\n\n\t\t\t} else {\n\n\t\t\t\tthis.pointerMesh.position.set( 0, 0, - 1 * rearRadius );\n\t\t\t\tthis.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis._updatePointerVertices( POINTER_REAR_RADIUS_MIN );\n\t\t\tthis.pointerMesh.position.set(\n\t\t\t\t0,\n\t\t\t\t0,\n\t\t\t\t- 1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX\n\t\t\t);\n\t\t\tthis.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\n\n\t\t}\n\n\t\tthis.cursorObject.material.opacity = this.pointerMesh.material.opacity;\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\t\tif ( this.pointerGeometry ) {\n\n\t\t\tthis._updatePointer();\n\t\t\tthis._updateRaycaster();\n\n\t\t}\n\n\t}\n\n\tisPinched() {\n\n\t\treturn this.pinched;\n\n\t}\n\n\tsetAttached( attached ) {\n\n\t\tthis.attached = attached;\n\n\t}\n\n\tisAttached() {\n\n\t\treturn this.attached;\n\n\t}\n\n\tintersectObject( object, recursive = true ) {\n\n\t\tif ( this.raycaster ) {\n\n\t\t\treturn this.raycaster.intersectObject( object, recursive );\n\n\t\t}\n\n\t}\n\n\tintersectObjects( objects, recursive = true ) {\n\n\t\tif ( this.raycaster ) {\n\n\t\t\treturn this.raycaster.intersectObjects( objects, recursive );\n\n\t\t}\n\n\t}\n\n\tcheckIntersections( objects, recursive = false ) {\n\n\t\tif ( this.raycaster && ! this.attached ) {\n\n\t\t\tconst intersections = this.raycaster.intersectObjects( objects, recursive );\n\t\t\tconst direction = new THREE.Vector3( 0, 0, - 1 );\n\t\t\tif ( intersections.length > 0 ) {\n\n\t\t\t\tconst intersection = intersections[ 0 ];\n\t\t\t\tconst distance = intersection.distance;\n\t\t\t\tthis.cursorObject.position.copy( direction.multiplyScalar( distance ) );\n\n\t\t\t} else {\n\n\t\t\t\tthis.cursorObject.position.copy( direction.multiplyScalar( CURSOR_MAX_DISTANCE ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tsetCursor( distance ) {\n\n\t\tconst direction = new THREE.Vector3( 0, 0, - 1 );\n\t\tif ( this.raycaster && ! this.attached ) {\n\n\t\t\tthis.cursorObject.position.copy( direction.multiplyScalar( distance ) );\n\n\t\t}\n\n\t}\n\n}\n\nexport { OculusHandPointerModel };\n"],
  "mappings": "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",
  "names": []
}
