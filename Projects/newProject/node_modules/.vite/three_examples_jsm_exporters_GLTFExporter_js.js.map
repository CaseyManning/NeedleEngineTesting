{
  "version": 3,
  "sources": ["../../../../Library/PackageCache/com.needle.engine@2.7.3-pre/package~/node_modules/three/examples/jsm/exporters/GLTFExporter.js"],
  "sourcesContent": ["import {\n\tBufferAttribute,\n\tClampToEdgeWrapping,\n\tDoubleSide,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tLinearFilter,\n\tLinearMipmapLinearFilter,\n\tLinearMipmapNearestFilter,\n\tMathUtils,\n\tMatrix4,\n\tMirroredRepeatWrapping,\n\tNearestFilter,\n\tNearestMipmapLinearFilter,\n\tNearestMipmapNearestFilter,\n\tPropertyBinding,\n\tRGBAFormat,\n\tRepeatWrapping,\n\tScene,\n\tSource,\n\tVector3\n} from 'three';\n\n\nclass GLTFExporter {\n\n\tconstructor() {\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFLightExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsUnlitExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsPBRSpecularGlossiness( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsVolumeExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsIridescenceExtension( writer );\n\n\t\t} );\n\n\t}\n\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Parse scenes and generate GLTF output\n\t * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n\t * @param  {Function} onDone  Callback on completed\n\t * @param  {Function} onError  Callback on errors\n\t * @param  {Object} options options\n\t */\n\tparse( input, onDone, onError, options ) {\n\n\t\tif ( typeof onError === 'object' ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: parse() expects options as the fourth argument now.' );\n\n\t\t\toptions = onError;\n\n\t\t}\n\n\t\tconst writer = new GLTFWriter();\n\t\tconst plugins = [];\n\n\t\tfor ( let i = 0, il = this.pluginCallbacks.length; i < il; i ++ ) {\n\n\t\t\tplugins.push( this.pluginCallbacks[ i ]( writer ) );\n\n\t\t}\n\n\t\twriter.setPlugins( plugins );\n\t\twriter.write( input, onDone, options ).catch( onError );\n\n\t}\n\n\tparseAsync( input, options ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.parse( input, resolve, reject, options );\n\n\t\t} );\n\n\t}\n\n}\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst WEBGL_CONSTANTS = {\n\tPOINTS: 0x0000,\n\tLINES: 0x0001,\n\tLINE_LOOP: 0x0002,\n\tLINE_STRIP: 0x0003,\n\tTRIANGLES: 0x0004,\n\tTRIANGLE_STRIP: 0x0005,\n\tTRIANGLE_FAN: 0x0006,\n\n\tUNSIGNED_BYTE: 0x1401,\n\tUNSIGNED_SHORT: 0x1403,\n\tFLOAT: 0x1406,\n\tUNSIGNED_INT: 0x1405,\n\tARRAY_BUFFER: 0x8892,\n\tELEMENT_ARRAY_BUFFER: 0x8893,\n\n\tNEAREST: 0x2600,\n\tLINEAR: 0x2601,\n\tNEAREST_MIPMAP_NEAREST: 0x2700,\n\tLINEAR_MIPMAP_NEAREST: 0x2701,\n\tNEAREST_MIPMAP_LINEAR: 0x2702,\n\tLINEAR_MIPMAP_LINEAR: 0x2703,\n\n\tCLAMP_TO_EDGE: 33071,\n\tMIRRORED_REPEAT: 33648,\n\tREPEAT: 10497\n};\n\nconst THREE_TO_WEBGL = {};\n\nTHREE_TO_WEBGL[ NearestFilter ] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[ NearestMipmapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[ NearestMipmapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ LinearFilter ] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[ LinearMipmapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[ LinearMipmapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\n\nTHREE_TO_WEBGL[ ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[ RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[ MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\tposition: 'translation',\n\tquaternion: 'rotation',\n\tmorphTargetInfluences: 'weights'\n};\n\n// GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 0x46546C67;\nconst GLB_VERSION = 2;\n\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\nconst GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\n//------------------------------------------------------------------------------\n// Utility functions\n//------------------------------------------------------------------------------\n\n/**\n * Compare two arrays\n * @param  {Array} array1 Array 1 to compare\n * @param  {Array} array2 Array 2 to compare\n * @return {Boolean}        Returns true if both arrays are equal\n */\nfunction equalArray( array1, array2 ) {\n\n\treturn ( array1.length === array2.length ) && array1.every( function ( element, index ) {\n\n\t\treturn element === array2[ index ];\n\n\t} );\n\n}\n\n/**\n * Converts a string to an ArrayBuffer.\n * @param  {string} text\n * @return {ArrayBuffer}\n */\nfunction stringToArrayBuffer( text ) {\n\n\treturn new TextEncoder().encode( text ).buffer;\n\n}\n\n/**\n * Is identity matrix\n *\n * @param {Matrix4} matrix\n * @returns {Boolean} Returns true, if parameter is identity matrix\n */\nfunction isIdentityMatrix( matrix ) {\n\n\treturn equalArray( matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] );\n\n}\n\n/**\n * Get the min and max vectors from the given attribute\n * @param  {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n * @param  {Integer} start\n * @param  {Integer} count\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n */\nfunction getMinMax( attribute, start, count ) {\n\n\tconst output = {\n\n\t\tmin: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),\n\t\tmax: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )\n\n\t};\n\n\tfor ( let i = start; i < start + count; i ++ ) {\n\n\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\tlet value;\n\n\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t} else {\n\n\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t}\n\n\t\t\toutput.min[ a ] = Math.min( output.min[ a ], value );\n\t\t\toutput.max[ a ] = Math.max( output.max[ a ], value );\n\n\t\t}\n\n\t}\n\n\treturn output;\n\n}\n\n/**\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n *\n * @param {Integer} bufferSize The size the original buffer.\n * @returns {Integer} new buffer size with required padding.\n *\n */\nfunction getPaddedBufferSize( bufferSize ) {\n\n\treturn Math.ceil( bufferSize / 4 ) * 4;\n\n}\n\n/**\n * Returns a buffer aligned to 4-byte boundary.\n *\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\n * @param {Integer} paddingByte (Optional)\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n */\nfunction getPaddedArrayBuffer( arrayBuffer, paddingByte = 0 ) {\n\n\tconst paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );\n\n\tif ( paddedLength !== arrayBuffer.byteLength ) {\n\n\t\tconst array = new Uint8Array( paddedLength );\n\t\tarray.set( new Uint8Array( arrayBuffer ) );\n\n\t\tif ( paddingByte !== 0 ) {\n\n\t\t\tfor ( let i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {\n\n\t\t\t\tarray[ i ] = paddingByte;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn array.buffer;\n\n\t}\n\n\treturn arrayBuffer;\n\n}\n\nlet cachedCanvas = null;\n\nfunction getCanvas() {\n\n\tif ( cachedCanvas ) {\n\n\t\treturn cachedCanvas;\n\n\t}\n\n\tif ( typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined' ) {\n\n\t\tcachedCanvas = new OffscreenCanvas( 1, 1 );\n\n\t} else {\n\n\t\tcachedCanvas = document.createElement( 'canvas' );\n\n\t}\n\n\treturn cachedCanvas;\n\n}\n\nfunction getToBlobPromise( canvas, mimeType ) {\n\n\tif ( canvas.toBlob !== undefined ) {\n\n\t\treturn new Promise( ( resolve ) => canvas.toBlob( resolve, mimeType ) );\n\n\t}\n\n\tlet quality;\n\n\t// Blink's implementation of convertToBlob seems to default to a quality level of 100%\n\t// Use the Blink default quality levels of toBlob instead so that file sizes are comparable.\n\tif ( mimeType === 'image/jpeg' ) {\n\n\t\tquality = 0.92;\n\n\t} else if ( mimeType === 'image/webp' ) {\n\n\t\tquality = 0.8;\n\n\t}\n\n\treturn canvas.convertToBlob( {\n\n\t\ttype: mimeType,\n\t\tquality: quality\n\n\t} );\n\n}\n\n/**\n * Writer\n */\nclass GLTFWriter {\n\n\tconstructor() {\n\n\t\tthis.plugins = [];\n\n\t\tthis.options = {};\n\t\tthis.pending = [];\n\t\tthis.buffers = [];\n\n\t\tthis.byteOffset = 0;\n\t\tthis.buffers = [];\n\t\tthis.nodeMap = new Map();\n\t\tthis.skins = [];\n\t\tthis.extensionsUsed = {};\n\n\t\tthis.uids = new Map();\n\t\tthis.uid = 0;\n\n\t\tthis.json = {\n\t\t\tasset: {\n\t\t\t\tversion: '2.0',\n\t\t\t\tgenerator: 'THREE.GLTFExporter'\n\t\t\t}\n\t\t};\n\n\t\tthis.cache = {\n\t\t\tmeshes: new Map(),\n\t\t\tattributes: new Map(),\n\t\t\tattributesNormalized: new Map(),\n\t\t\tmaterials: new Map(),\n\t\t\ttextures: new Map(),\n\t\t\timages: new Map()\n\t\t};\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\t/**\n\t * Parse scenes and generate GLTF output\n\t * @param  {Scene or [THREE.Scenes]} input   Scene or Array of THREE.Scenes\n\t * @param  {Function} onDone  Callback on completed\n\t * @param  {Object} options options\n\t */\n\tasync write( input, onDone, options ) {\n\n\t\tthis.options = Object.assign( {}, {\n\t\t\t// default options\n\t\t\tbinary: false,\n\t\t\ttrs: false,\n\t\t\tonlyVisible: true,\n\t\t\ttruncateDrawRange: true,\n\t\t\tmaxTextureSize: Infinity,\n\t\t\tanimations: [],\n\t\t\tincludeCustomExtensions: false\n\t\t}, options );\n\n\t\tif ( this.options.animations.length > 0 ) {\n\n\t\t\t// Only TRS properties, and not matrices, may be targeted by animation.\n\t\t\tthis.options.trs = true;\n\n\t\t}\n\n\t\tthis.processInput( input );\n\n\t\tawait Promise.all( this.pending );\n\n\t\tconst writer = this;\n\t\tconst buffers = writer.buffers;\n\t\tconst json = writer.json;\n\t\toptions = writer.options;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\t// Merge buffers.\n\t\tconst blob = new Blob( buffers, { type: 'application/octet-stream' } );\n\n\t\t// Declare extensions.\n\t\tconst extensionsUsedList = Object.keys( extensionsUsed );\n\n\t\tif ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList;\n\n\t\t// Update bytelength of the single buffer.\n\t\tif ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;\n\n\t\tif ( options.binary === true ) {\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n\t\t\tconst reader = new FileReader();\n\t\t\treader.readAsArrayBuffer( blob );\n\t\t\treader.onloadend = function () {\n\n\t\t\t\t// Binary chunk.\n\t\t\t\tconst binaryChunk = getPaddedArrayBuffer( reader.result );\n\t\t\t\tconst binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\tbinaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );\n\t\t\t\tbinaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );\n\n\t\t\t\t// JSON chunk.\n\t\t\t\tconst jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );\n\t\t\t\tconst jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\tjsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );\n\t\t\t\tjsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );\n\n\t\t\t\t// GLB header.\n\t\t\t\tconst header = new ArrayBuffer( GLB_HEADER_BYTES );\n\t\t\t\tconst headerView = new DataView( header );\n\t\t\t\theaderView.setUint32( 0, GLB_HEADER_MAGIC, true );\n\t\t\t\theaderView.setUint32( 4, GLB_VERSION, true );\n\t\t\t\tconst totalByteLength = GLB_HEADER_BYTES\n\t\t\t\t\t+ jsonChunkPrefix.byteLength + jsonChunk.byteLength\n\t\t\t\t\t+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n\t\t\t\theaderView.setUint32( 8, totalByteLength, true );\n\n\t\t\t\tconst glbBlob = new Blob( [\n\t\t\t\t\theader,\n\t\t\t\t\tjsonChunkPrefix,\n\t\t\t\t\tjsonChunk,\n\t\t\t\t\tbinaryChunkPrefix,\n\t\t\t\t\tbinaryChunk\n\t\t\t\t], { type: 'application/octet-stream' } );\n\n\t\t\t\tconst glbReader = new FileReader();\n\t\t\t\tglbReader.readAsArrayBuffer( glbBlob );\n\t\t\t\tglbReader.onloadend = function () {\n\n\t\t\t\t\tonDone( glbReader.result );\n\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tif ( json.buffers && json.buffers.length > 0 ) {\n\n\t\t\t\tconst reader = new FileReader();\n\t\t\t\treader.readAsDataURL( blob );\n\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\tconst base64data = reader.result;\n\t\t\t\t\tjson.buffers[ 0 ].uri = base64data;\n\t\t\t\t\tonDone( json );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tonDone( json );\n\n\t\t\t}\n\n\t\t}\n\n\n\t}\n\n\t/**\n\t * Serializes a userData.\n\t *\n\t * @param {THREE.Object3D|THREE.Material} object\n\t * @param {Object} objectDef\n\t */\n\tserializeUserData( object, objectDef ) {\n\n\t\tif ( Object.keys( object.userData ).length === 0 ) return;\n\n\t\tconst options = this.options;\n\t\tconst extensionsUsed = this.extensionsUsed;\n\n\t\ttry {\n\n\t\t\tconst json = JSON.parse( JSON.stringify( object.userData ) );\n\n\t\t\tif ( options.includeCustomExtensions && json.gltfExtensions ) {\n\n\t\t\t\tif ( objectDef.extensions === undefined ) objectDef.extensions = {};\n\n\t\t\t\tfor ( const extensionName in json.gltfExtensions ) {\n\n\t\t\t\t\tobjectDef.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];\n\t\t\t\t\textensionsUsed[ extensionName ] = true;\n\n\t\t\t\t}\n\n\t\t\t\tdelete json.gltfExtensions;\n\n\t\t\t}\n\n\t\t\tif ( Object.keys( json ).length > 0 ) objectDef.extras = json;\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' +\n\t\t\t\t'won\\'t be serialized because of JSON.stringify error - ' + error.message );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns ids for buffer attributes.\n\t * @param  {Object} object\n\t * @return {Integer}\n\t */\n\tgetUID( attribute, isRelativeCopy = false ) {\n\n\t\tif ( this.uids.has( attribute ) === false ) {\n\n\t\t\tconst uids = new Map();\n\n\t\t\tuids.set( true, this.uid ++ );\n\t\t\tuids.set( false, this.uid ++ );\n\n\t\t\tthis.uids.set( attribute, uids );\n\n\t\t}\n\n\t\tconst uids = this.uids.get( attribute );\n\n\t\treturn uids.get( isRelativeCopy );\n\n\t}\n\n\t/**\n\t * Checks if normal attribute values are normalized.\n\t *\n\t * @param {BufferAttribute} normal\n\t * @returns {Boolean}\n\t */\n\tisNormalizedNormalAttribute( normal ) {\n\n\t\tconst cache = this.cache;\n\n\t\tif ( cache.attributesNormalized.has( normal ) ) return false;\n\n\t\tconst v = new Vector3();\n\n\t\tfor ( let i = 0, il = normal.count; i < il; i ++ ) {\n\n\t\t\t// 0.0005 is from glTF-validator\n\t\t\tif ( Math.abs( v.fromBufferAttribute( normal, i ).length() - 1.0 ) > 0.0005 ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Creates normalized normal buffer attribute.\n\t *\n\t * @param {BufferAttribute} normal\n\t * @returns {BufferAttribute}\n\t *\n\t */\n\tcreateNormalizedNormalAttribute( normal ) {\n\n\t\tconst cache = this.cache;\n\n\t\tif ( cache.attributesNormalized.has( normal ) )\treturn cache.attributesNormalized.get( normal );\n\n\t\tconst attribute = normal.clone();\n\t\tconst v = new Vector3();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\tv.fromBufferAttribute( attribute, i );\n\n\t\t\tif ( v.x === 0 && v.y === 0 && v.z === 0 ) {\n\n\t\t\t\t// if values can't be normalized set (1, 0, 0)\n\t\t\t\tv.setX( 1.0 );\n\n\t\t\t} else {\n\n\t\t\t\tv.normalize();\n\n\t\t\t}\n\n\t\t\tattribute.setXYZ( i, v.x, v.y, v.z );\n\n\t\t}\n\n\t\tcache.attributesNormalized.set( normal, attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\t/**\n\t * Applies a texture transform, if present, to the map definition. Requires\n\t * the KHR_texture_transform extension.\n\t *\n\t * @param {Object} mapDef\n\t * @param {THREE.Texture} texture\n\t */\n\tapplyTextureTransform( mapDef, texture ) {\n\n\t\tlet didTransform = false;\n\t\tconst transformDef = {};\n\n\t\tif ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {\n\n\t\t\ttransformDef.offset = texture.offset.toArray();\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( texture.rotation !== 0 ) {\n\n\t\t\ttransformDef.rotation = texture.rotation;\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {\n\n\t\t\ttransformDef.scale = texture.repeat.toArray();\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( didTransform ) {\n\n\t\t\tmapDef.extensions = mapDef.extensions || {};\n\t\t\tmapDef.extensions[ 'KHR_texture_transform' ] = transformDef;\n\t\t\tthis.extensionsUsed[ 'KHR_texture_transform' ] = true;\n\n\t\t}\n\n\t}\n\n\tbuildMetalRoughTexture( metalnessMap, roughnessMap ) {\n\n\t\tif ( metalnessMap === roughnessMap ) return metalnessMap;\n\n\t\tconsole.warn( 'THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.' );\n\n\t\tconst metalness = metalnessMap?.image;\n\t\tconst roughness = roughnessMap?.image;\n\n\t\tconst width = Math.max( metalness?.width || 0, roughness?.width || 0 );\n\t\tconst height = Math.max( metalness?.height || 0, roughness?.height || 0 );\n\n\t\tconst canvas = getCanvas();\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\n\t\tconst context = canvas.getContext( '2d' );\n\t\tcontext.fillStyle = '#00ffff';\n\t\tcontext.fillRect( 0, 0, width, height );\n\n\t\tconst composite = context.getImageData( 0, 0, width, height );\n\n\t\tif ( metalness ) {\n\n\t\t\tcontext.drawImage( metalness, 0, 0, width, height );\n\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\n\n\t\t\tfor ( let i = 2; i < data.length; i += 4 ) {\n\n\t\t\t\tcomposite.data[ i ] = data[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( roughness ) {\n\n\t\t\tcontext.drawImage( roughness, 0, 0, width, height );\n\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\n\n\t\t\tfor ( let i = 1; i < data.length; i += 4 ) {\n\n\t\t\t\tcomposite.data[ i ] = data[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tcontext.putImageData( composite, 0, 0 );\n\n\t\t//\n\n\t\tconst reference = metalnessMap || roughnessMap;\n\n\t\tconst texture = reference.clone();\n\n\t\ttexture.source = new Source( canvas );\n\n\t\treturn texture;\n\n\t}\n\n\t/**\n\t * Process a buffer to append to the default one.\n\t * @param  {ArrayBuffer} buffer\n\t * @return {Integer}\n\t */\n\tprocessBuffer( buffer ) {\n\n\t\tconst json = this.json;\n\t\tconst buffers = this.buffers;\n\n\t\tif ( ! json.buffers ) json.buffers = [ { byteLength: 0 } ];\n\n\t\t// All buffers are merged before export.\n\t\tbuffers.push( buffer );\n\n\t\treturn 0;\n\n\t}\n\n\t/**\n\t * Process and generate a BufferView\n\t * @param  {BufferAttribute} attribute\n\t * @param  {number} componentType\n\t * @param  {number} start\n\t * @param  {number} count\n\t * @param  {number} target (Optional) Target usage of the BufferView\n\t * @return {Object}\n\t */\n\tprocessBufferView( attribute, componentType, start, count, target ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\t// Create a new dataview and dump the attribute's array into it\n\n\t\tlet componentSize;\n\n\t\tif ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\tcomponentSize = 1;\n\n\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\tcomponentSize = 2;\n\n\t\t} else {\n\n\t\t\tcomponentSize = 4;\n\n\t\t}\n\n\t\tconst byteLength = getPaddedBufferSize( count * attribute.itemSize * componentSize );\n\t\tconst dataView = new DataView( new ArrayBuffer( byteLength ) );\n\t\tlet offset = 0;\n\n\t\tfor ( let i = start; i < start + count; i ++ ) {\n\n\t\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\tlet value;\n\n\t\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t\t}\n\n\t\t\t\tif ( componentType === WEBGL_CONSTANTS.FLOAT ) {\n\n\t\t\t\t\tdataView.setFloat32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {\n\n\t\t\t\t\tdataView.setUint32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\t\t\tdataView.setUint16( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\t\t\tdataView.setUint8( offset, value );\n\n\t\t\t\t}\n\n\t\t\t\toffset += componentSize;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bufferViewDef = {\n\n\t\t\tbuffer: this.processBuffer( dataView.buffer ),\n\t\t\tbyteOffset: this.byteOffset,\n\t\t\tbyteLength: byteLength\n\n\t\t};\n\n\t\tif ( target !== undefined ) bufferViewDef.target = target;\n\n\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\n\n\t\t\t// Only define byteStride for vertex attributes.\n\t\t\tbufferViewDef.byteStride = attribute.itemSize * componentSize;\n\n\t\t}\n\n\t\tthis.byteOffset += byteLength;\n\n\t\tjson.bufferViews.push( bufferViewDef );\n\n\t\t// @TODO Merge bufferViews where possible.\n\t\tconst output = {\n\n\t\t\tid: json.bufferViews.length - 1,\n\t\t\tbyteLength: 0\n\n\t\t};\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Process and generate a BufferView from an image Blob.\n\t * @param {Blob} blob\n\t * @return {Promise<Integer>}\n\t */\n\tprocessBufferViewImage( blob ) {\n\n\t\tconst writer = this;\n\t\tconst json = writer.json;\n\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\treturn new Promise( function ( resolve ) {\n\n\t\t\tconst reader = new FileReader();\n\t\t\treader.readAsArrayBuffer( blob );\n\t\t\treader.onloadend = function () {\n\n\t\t\t\tconst buffer = getPaddedArrayBuffer( reader.result );\n\n\t\t\t\tconst bufferViewDef = {\n\t\t\t\t\tbuffer: writer.processBuffer( buffer ),\n\t\t\t\t\tbyteOffset: writer.byteOffset,\n\t\t\t\t\tbyteLength: buffer.byteLength\n\t\t\t\t};\n\n\t\t\t\twriter.byteOffset += buffer.byteLength;\n\t\t\t\tresolve( json.bufferViews.push( bufferViewDef ) - 1 );\n\n\t\t\t};\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Process attribute to generate an accessor\n\t * @param  {BufferAttribute} attribute Attribute to process\n\t * @param  {THREE.BufferGeometry} geometry (Optional) Geometry used for truncated draw range\n\t * @param  {Integer} start (Optional)\n\t * @param  {Integer} count (Optional)\n\t * @return {Integer|null} Index of the processed accessor on the \"accessors\" array\n\t */\n\tprocessAccessor( attribute, geometry, start, count ) {\n\n\t\tconst options = this.options;\n\t\tconst json = this.json;\n\n\t\tconst types = {\n\n\t\t\t1: 'SCALAR',\n\t\t\t2: 'VEC2',\n\t\t\t3: 'VEC3',\n\t\t\t4: 'VEC4',\n\t\t\t16: 'MAT4'\n\n\t\t};\n\n\t\tlet componentType;\n\n\t\t// Detect the component type of the attribute array (float, uint or ushort)\n\t\tif ( attribute.array.constructor === Float32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.FLOAT;\n\n\t\t} else if ( attribute.array.constructor === Uint32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n\n\t\t} else if ( attribute.array.constructor === Uint16Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n\n\t\t} else if ( attribute.array.constructor === Uint8Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type.' );\n\n\t\t}\n\n\t\tif ( start === undefined ) start = 0;\n\t\tif ( count === undefined ) count = attribute.count;\n\n\t\t// @TODO Indexed buffer geometry with drawRange not supported yet\n\t\tif ( options.truncateDrawRange && geometry !== undefined && geometry.index === null ) {\n\n\t\t\tconst end = start + count;\n\t\t\tconst end2 = geometry.drawRange.count === Infinity\n\t\t\t\t? attribute.count\n\t\t\t\t: geometry.drawRange.start + geometry.drawRange.count;\n\n\t\t\tstart = Math.max( start, geometry.drawRange.start );\n\t\t\tcount = Math.min( end, end2 ) - start;\n\n\t\t\tif ( count < 0 ) count = 0;\n\n\t\t}\n\n\t\t// Skip creating an accessor if the attribute doesn't have data to export\n\t\tif ( count === 0 ) return null;\n\n\t\tconst minMax = getMinMax( attribute, start, count );\n\t\tlet bufferViewTarget;\n\n\t\t// If geometry isn't provided, don't infer the target usage of the bufferView. For\n\t\t// animation samplers, target must not be set.\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tbufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n\n\t\t}\n\n\t\tconst bufferView = this.processBufferView( attribute, componentType, start, count, bufferViewTarget );\n\n\t\tconst accessorDef = {\n\n\t\t\tbufferView: bufferView.id,\n\t\t\tbyteOffset: bufferView.byteOffset,\n\t\t\tcomponentType: componentType,\n\t\t\tcount: count,\n\t\t\tmax: minMax.max,\n\t\t\tmin: minMax.min,\n\t\t\ttype: types[ attribute.itemSize ]\n\n\t\t};\n\n\t\tif ( attribute.normalized === true ) accessorDef.normalized = true;\n\t\tif ( ! json.accessors ) json.accessors = [];\n\n\t\treturn json.accessors.push( accessorDef ) - 1;\n\n\t}\n\n\t/**\n\t * Process image\n\t * @param  {Image} image to process\n\t * @param  {Integer} format of the image (RGBAFormat)\n\t * @param  {Boolean} flipY before writing out the image\n\t * @param  {String} mimeType export format\n\t * @return {Integer}     Index of the processed texture in the \"images\" array\n\t */\n\tprocessImage( image, format, flipY, mimeType = 'image/png' ) {\n\n\t\tconst writer = this;\n\t\tconst cache = writer.cache;\n\t\tconst json = writer.json;\n\t\tconst options = writer.options;\n\t\tconst pending = writer.pending;\n\n\t\tif ( ! cache.images.has( image ) ) cache.images.set( image, {} );\n\n\t\tconst cachedImages = cache.images.get( image );\n\n\t\tconst key = mimeType + ':flipY/' + flipY.toString();\n\n\t\tif ( cachedImages[ key ] !== undefined ) return cachedImages[ key ];\n\n\t\tif ( ! json.images ) json.images = [];\n\n\t\tconst imageDef = { mimeType: mimeType };\n\n\t\tconst canvas = getCanvas();\n\n\t\tcanvas.width = Math.min( image.width, options.maxTextureSize );\n\t\tcanvas.height = Math.min( image.height, options.maxTextureSize );\n\n\t\tconst ctx = canvas.getContext( '2d' );\n\n\t\tif ( flipY === true ) {\n\n\t\t\tctx.translate( 0, canvas.height );\n\t\t\tctx.scale( 1, - 1 );\n\n\t\t}\n\n\t\tif ( image.data !== undefined ) { // THREE.DataTexture\n\n\t\t\tif ( format !== RGBAFormat ) {\n\n\t\t\t\tconsole.error( 'GLTFExporter: Only RGBAFormat is supported.' );\n\n\t\t\t}\n\n\t\t\tif ( image.width > options.maxTextureSize || image.height > options.maxTextureSize ) {\n\n\t\t\t\tconsole.warn( 'GLTFExporter: Image size is bigger than maxTextureSize', image );\n\n\t\t\t}\n\n\t\t\tconst data = new Uint8ClampedArray( image.height * image.width * 4 );\n\n\t\t\tfor ( let i = 0; i < data.length; i += 4 ) {\n\n\t\t\t\tdata[ i + 0 ] = image.data[ i + 0 ];\n\t\t\t\tdata[ i + 1 ] = image.data[ i + 1 ];\n\t\t\t\tdata[ i + 2 ] = image.data[ i + 2 ];\n\t\t\t\tdata[ i + 3 ] = image.data[ i + 3 ];\n\n\t\t\t}\n\n\t\t\tctx.putImageData( new ImageData( data, image.width, image.height ), 0, 0 );\n\n\t\t} else {\n\n\t\t\tctx.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t}\n\n\t\tif ( options.binary === true ) {\n\n\t\t\tpending.push(\n\n\t\t\t\tgetToBlobPromise( canvas, mimeType )\n\t\t\t\t\t.then( blob => writer.processBufferViewImage( blob ) )\n\t\t\t\t\t.then( bufferViewIndex => {\n\n\t\t\t\t\t\timageDef.bufferView = bufferViewIndex;\n\n\t\t\t\t\t} )\n\n\t\t\t);\n\n\t\t} else {\n\n\t\t\tif ( canvas.toDataURL !== undefined ) {\n\n\t\t\t\timageDef.uri = canvas.toDataURL( mimeType );\n\n\t\t\t} else {\n\n\t\t\t\tpending.push(\n\n\t\t\t\t\tgetToBlobPromise( canvas, mimeType )\n\t\t\t\t\t\t.then( blob => new FileReader().readAsDataURL( blob ) )\n\t\t\t\t\t\t.then( dataURL => {\n\n\t\t\t\t\t\t\timageDef.uri = dataURL;\n\n\t\t\t\t\t\t} )\n\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst index = json.images.push( imageDef ) - 1;\n\t\tcachedImages[ key ] = index;\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process sampler\n\t * @param  {Texture} map Texture to process\n\t * @return {Integer}     Index of the processed texture in the \"samplers\" array\n\t */\n\tprocessSampler( map ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.samplers ) json.samplers = [];\n\n\t\tconst samplerDef = {\n\t\t\tmagFilter: THREE_TO_WEBGL[ map.magFilter ],\n\t\t\tminFilter: THREE_TO_WEBGL[ map.minFilter ],\n\t\t\twrapS: THREE_TO_WEBGL[ map.wrapS ],\n\t\t\twrapT: THREE_TO_WEBGL[ map.wrapT ]\n\t\t};\n\n\t\treturn json.samplers.push( samplerDef ) - 1;\n\n\t}\n\n\t/**\n\t * Process texture\n\t * @param  {Texture} map Map to process\n\t * @return {Integer} Index of the processed texture in the \"textures\" array\n\t */\n\tprocessTexture( map ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tif ( cache.textures.has( map ) ) return cache.textures.get( map );\n\n\t\tif ( ! json.textures ) json.textures = [];\n\n\t\tlet mimeType = map.userData.mimeType;\n\n\t\tif ( mimeType === 'image/webp' ) mimeType = 'image/png';\n\n\t\tconst textureDef = {\n\t\t\tsampler: this.processSampler( map ),\n\t\t\tsource: this.processImage( map.image, map.format, map.flipY, mimeType )\n\t\t};\n\n\t\tif ( map.name ) textureDef.name = map.name;\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeTexture && ext.writeTexture( map, textureDef );\n\n\t\t} );\n\n\t\tconst index = json.textures.push( textureDef ) - 1;\n\t\tcache.textures.set( map, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process material\n\t * @param  {THREE.Material} material Material to process\n\t * @return {Integer|null} Index of the processed material in the \"materials\" array\n\t */\n\tprocessMaterial( material ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tif ( cache.materials.has( material ) ) return cache.materials.get( material );\n\n\t\tif ( material.isShaderMaterial ) {\n\n\t\t\tconsole.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( ! json.materials ) json.materials = [];\n\n\t\t// @QUESTION Should we avoid including any attribute that has the default value?\n\t\tconst materialDef = {\tpbrMetallicRoughness: {} };\n\n\t\tif ( material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true ) {\n\n\t\t\tconsole.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.baseColorFactor\n\t\tconst color = material.color.toArray().concat( [ material.opacity ] );\n\n\t\tif ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorFactor = color;\n\n\t\t}\n\n\t\tif ( material.isMeshStandardMaterial ) {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n\n\t\t} else {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.5;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.5;\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.metallicRoughnessTexture\n\t\tif ( material.metalnessMap || material.roughnessMap ) {\n\n\t\t\tconst metalRoughTexture = this.buildMetalRoughTexture( material.metalnessMap, material.roughnessMap );\n\n\t\t\tconst metalRoughMapDef = { index: this.processTexture( metalRoughTexture ) };\n\t\t\tthis.applyTextureTransform( metalRoughMapDef, metalRoughTexture );\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.baseColorTexture or pbrSpecularGlossiness diffuseTexture\n\t\tif ( material.map ) {\n\n\t\t\tconst baseColorMapDef = { index: this.processTexture( material.map ) };\n\t\t\tthis.applyTextureTransform( baseColorMapDef, material.map );\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n\n\t\t}\n\n\t\tif ( material.emissive ) {\n\n\t\t\t// note: emissive components are limited to stay within the 0 - 1 range to accommodate glTF spec. see #21849 and #22000.\n\t\t\tconst emissive = material.emissive.clone().multiplyScalar( material.emissiveIntensity );\n\t\t\tconst maxEmissiveComponent = Math.max( emissive.r, emissive.g, emissive.b );\n\n\t\t\tif ( maxEmissiveComponent > 1 ) {\n\n\t\t\t\temissive.multiplyScalar( 1 / maxEmissiveComponent );\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited' );\n\n\t\t\t}\n\n\t\t\tif ( maxEmissiveComponent > 0 ) {\n\n\t\t\t\tmaterialDef.emissiveFactor = emissive.toArray();\n\n\t\t\t}\n\n\t\t\t// emissiveTexture\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tconst emissiveMapDef = { index: this.processTexture( material.emissiveMap ) };\n\t\t\t\tthis.applyTextureTransform( emissiveMapDef, material.emissiveMap );\n\t\t\t\tmaterialDef.emissiveTexture = emissiveMapDef;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// normalTexture\n\t\tif ( material.normalMap ) {\n\n\t\t\tconst normalMapDef = { index: this.processTexture( material.normalMap ) };\n\n\t\t\tif ( material.normalScale && material.normalScale.x !== 1 ) {\n\n\t\t\t\t// glTF normal scale is univariate. Ignore `y`, which may be flipped.\n\t\t\t\t// Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\tnormalMapDef.scale = material.normalScale.x;\n\n\t\t\t}\n\n\t\t\tthis.applyTextureTransform( normalMapDef, material.normalMap );\n\t\t\tmaterialDef.normalTexture = normalMapDef;\n\n\t\t}\n\n\t\t// occlusionTexture\n\t\tif ( material.aoMap ) {\n\n\t\t\tconst occlusionMapDef = {\n\t\t\t\tindex: this.processTexture( material.aoMap ),\n\t\t\t\ttexCoord: 1\n\t\t\t};\n\n\t\t\tif ( material.aoMapIntensity !== 1.0 ) {\n\n\t\t\t\tocclusionMapDef.strength = material.aoMapIntensity;\n\n\t\t\t}\n\n\t\t\tthis.applyTextureTransform( occlusionMapDef, material.aoMap );\n\t\t\tmaterialDef.occlusionTexture = occlusionMapDef;\n\n\t\t}\n\n\t\t// alphaMode\n\t\tif ( material.transparent ) {\n\n\t\t\tmaterialDef.alphaMode = 'BLEND';\n\n\t\t} else {\n\n\t\t\tif ( material.alphaTest > 0.0 ) {\n\n\t\t\t\tmaterialDef.alphaMode = 'MASK';\n\t\t\t\tmaterialDef.alphaCutoff = material.alphaTest;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// doubleSided\n\t\tif ( material.side === DoubleSide ) materialDef.doubleSided = true;\n\t\tif ( material.name !== '' ) materialDef.name = material.name;\n\n\t\tthis.serializeUserData( material, materialDef );\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeMaterial && ext.writeMaterial( material, materialDef );\n\n\t\t} );\n\n\t\tconst index = json.materials.push( materialDef ) - 1;\n\t\tcache.materials.set( material, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process mesh\n\t * @param  {THREE.Mesh} mesh Mesh to process\n\t * @return {Integer|null} Index of the processed mesh in the \"meshes\" array\n\t */\n\tprocessMesh( mesh ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tconst meshCacheKeyParts = [ mesh.geometry.uuid ];\n\n\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\tfor ( let i = 0, l = mesh.material.length; i < l; i ++ ) {\n\n\t\t\t\tmeshCacheKeyParts.push( mesh.material[ i ].uuid\t);\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmeshCacheKeyParts.push( mesh.material.uuid );\n\n\t\t}\n\n\t\tconst meshCacheKey = meshCacheKeyParts.join( ':' );\n\n\t\tif ( cache.meshes.has( meshCacheKey ) ) return cache.meshes.get( meshCacheKey );\n\n\t\tconst geometry = mesh.geometry;\n\n\t\tlet mode;\n\n\t\t// Use the correct mode\n\t\tif ( mesh.isLineSegments ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINES;\n\n\t\t} else if ( mesh.isLineLoop ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINE_LOOP;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINE_STRIP;\n\n\t\t} else if ( mesh.isPoints ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.POINTS;\n\n\t\t} else {\n\n\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n\n\t\t}\n\n\t\tif ( geometry.isBufferGeometry !== true ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.' );\n\n\t\t}\n\n\t\tconst meshDef = {};\n\t\tconst attributes = {};\n\t\tconst primitives = [];\n\t\tconst targets = [];\n\n\t\t// Conversion between attributes names in threejs and gltf spec\n\t\tconst nameConversion = {\n\t\t\tuv: 'TEXCOORD_0',\n\t\t\tuv2: 'TEXCOORD_1',\n\t\t\tcolor: 'COLOR_0',\n\t\t\tskinWeight: 'WEIGHTS_0',\n\t\t\tskinIndex: 'JOINTS_0'\n\t\t};\n\n\t\tconst originalNormal = geometry.getAttribute( 'normal' );\n\n\t\tif ( originalNormal !== undefined && ! this.isNormalizedNormalAttribute( originalNormal ) ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );\n\n\t\t\tgeometry.setAttribute( 'normal', this.createNormalizedNormalAttribute( originalNormal ) );\n\n\t\t}\n\n\t\t// @QUESTION Detect if .vertexColors = true?\n\t\t// For every attribute create an accessor\n\t\tlet modifiedAttribute = null;\n\n\t\tfor ( let attributeName in geometry.attributes ) {\n\n\t\t\t// Ignore morph target attributes, which are exported later.\n\t\t\tif ( attributeName.slice( 0, 5 ) === 'morph' ) continue;\n\n\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\tattributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();\n\n\t\t\t// Prefix all geometry attributes except the ones specifically\n\t\t\t// listed in the spec; non-spec attributes are considered custom.\n\t\t\tconst validVertexAttributes =\n\t\t\t\t\t/^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n\n\t\t\tif ( ! validVertexAttributes.test( attributeName ) ) attributeName = '_' + attributeName;\n\n\t\t\tif ( cache.attributes.has( this.getUID( attribute ) ) ) {\n\n\t\t\t\tattributes[ attributeName ] = cache.attributes.get( this.getUID( attribute ) );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT.\n\t\t\tmodifiedAttribute = null;\n\t\t\tconst array = attribute.array;\n\n\t\t\tif ( attributeName === 'JOINTS_0' &&\n\t\t\t\t! ( array instanceof Uint16Array ) &&\n\t\t\t\t! ( array instanceof Uint8Array ) ) {\n\n\t\t\t\tconsole.warn( 'GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.' );\n\t\t\t\tmodifiedAttribute = new BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );\n\n\t\t\t}\n\n\t\t\tconst accessor = this.processAccessor( modifiedAttribute || attribute, geometry );\n\n\t\t\tif ( accessor !== null ) {\n\n\t\t\t\tattributes[ attributeName ] = accessor;\n\t\t\t\tcache.attributes.set( this.getUID( attribute ), accessor );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal );\n\n\t\t// Skip if no exportable attributes found\n\t\tif ( Object.keys( attributes ).length === 0 ) return null;\n\n\t\t// Morph targets\n\t\tif ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {\n\n\t\t\tconst weights = [];\n\t\t\tconst targetNames = [];\n\t\t\tconst reverseDictionary = {};\n\n\t\t\tif ( mesh.morphTargetDictionary !== undefined ) {\n\n\t\t\t\tfor ( const key in mesh.morphTargetDictionary ) {\n\n\t\t\t\t\treverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {\n\n\t\t\t\tconst target = {};\n\t\t\t\tlet warned = false;\n\n\t\t\t\tfor ( const attributeName in geometry.morphAttributes ) {\n\n\t\t\t\t\t// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n\t\t\t\t\t// Three.js doesn't support TANGENT yet.\n\n\t\t\t\t\tif ( attributeName !== 'position' && attributeName !== 'normal' ) {\n\n\t\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );\n\t\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst attribute = geometry.morphAttributes[ attributeName ][ i ];\n\t\t\t\t\tconst gltfAttributeName = attributeName.toUpperCase();\n\n\t\t\t\t\t// Three.js morph attribute has absolute values while the one of glTF has relative values.\n\t\t\t\t\t//\n\t\t\t\t\t// glTF 2.0 Specification:\n\t\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n\t\t\t\t\tconst baseAttribute = geometry.attributes[ attributeName ];\n\n\t\t\t\t\tif ( cache.attributes.has( this.getUID( attribute, true ) ) ) {\n\n\t\t\t\t\t\ttarget[ gltfAttributeName ] = cache.attributes.get( this.getUID( attribute, true ) );\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Clones attribute not to override\n\t\t\t\t\tconst relativeAttribute = attribute.clone();\n\n\t\t\t\t\tif ( ! geometry.morphTargetsRelative ) {\n\n\t\t\t\t\t\tfor ( let j = 0, jl = attribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\trelativeAttribute.setXYZ(\n\t\t\t\t\t\t\t\tj,\n\t\t\t\t\t\t\t\tattribute.getX( j ) - baseAttribute.getX( j ),\n\t\t\t\t\t\t\t\tattribute.getY( j ) - baseAttribute.getY( j ),\n\t\t\t\t\t\t\t\tattribute.getZ( j ) - baseAttribute.getZ( j )\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttarget[ gltfAttributeName ] = this.processAccessor( relativeAttribute, geometry );\n\t\t\t\t\tcache.attributes.set( this.getUID( baseAttribute, true ), target[ gltfAttributeName ] );\n\n\t\t\t\t}\n\n\t\t\t\ttargets.push( target );\n\n\t\t\t\tweights.push( mesh.morphTargetInfluences[ i ] );\n\n\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );\n\n\t\t\t}\n\n\t\t\tmeshDef.weights = weights;\n\n\t\t\tif ( targetNames.length > 0 ) {\n\n\t\t\t\tmeshDef.extras = {};\n\t\t\t\tmeshDef.extras.targetNames = targetNames;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst isMultiMaterial = Array.isArray( mesh.material );\n\n\t\tif ( isMultiMaterial && geometry.groups.length === 0 ) return null;\n\n\t\tconst materials = isMultiMaterial ? mesh.material : [ mesh.material ];\n\t\tconst groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];\n\n\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = {\n\t\t\t\tmode: mode,\n\t\t\t\tattributes: attributes,\n\t\t\t};\n\n\t\t\tthis.serializeUserData( geometry, primitive );\n\n\t\t\tif ( targets.length > 0 ) primitive.targets = targets;\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\tlet cacheKey = this.getUID( geometry.index );\n\n\t\t\t\tif ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {\n\n\t\t\t\t\tcacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;\n\n\t\t\t\t}\n\n\t\t\t\tif ( cache.attributes.has( cacheKey ) ) {\n\n\t\t\t\t\tprimitive.indices = cache.attributes.get( cacheKey );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tprimitive.indices = this.processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );\n\t\t\t\t\tcache.attributes.set( cacheKey, primitive.indices );\n\n\t\t\t\t}\n\n\t\t\t\tif ( primitive.indices === null ) delete primitive.indices;\n\n\t\t\t}\n\n\t\t\tconst material = this.processMaterial( materials[ groups[ i ].materialIndex ] );\n\n\t\t\tif ( material !== null ) primitive.material = material;\n\n\t\t\tprimitives.push( primitive );\n\n\t\t}\n\n\t\tmeshDef.primitives = primitives;\n\n\t\tif ( ! json.meshes ) json.meshes = [];\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeMesh && ext.writeMesh( mesh, meshDef );\n\n\t\t} );\n\n\t\tconst index = json.meshes.push( meshDef ) - 1;\n\t\tcache.meshes.set( meshCacheKey, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process camera\n\t * @param  {THREE.Camera} camera Camera to process\n\t * @return {Integer}      Index of the processed mesh in the \"camera\" array\n\t */\n\tprocessCamera( camera ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.cameras ) json.cameras = [];\n\n\t\tconst isOrtho = camera.isOrthographicCamera;\n\n\t\tconst cameraDef = {\n\t\t\ttype: isOrtho ? 'orthographic' : 'perspective'\n\t\t};\n\n\t\tif ( isOrtho ) {\n\n\t\t\tcameraDef.orthographic = {\n\t\t\t\txmag: camera.right * 2,\n\t\t\t\tymag: camera.top * 2,\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tcameraDef.perspective = {\n\t\t\t\taspectRatio: camera.aspect,\n\t\t\t\tyfov: MathUtils.degToRad( camera.fov ),\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t};\n\n\t\t}\n\n\t\t// Question: Is saving \"type\" as name intentional?\n\t\tif ( camera.name !== '' ) cameraDef.name = camera.type;\n\n\t\treturn json.cameras.push( cameraDef ) - 1;\n\n\t}\n\n\t/**\n\t * Creates glTF animation entry from AnimationClip object.\n\t *\n\t * Status:\n\t * - Only properties listed in PATH_PROPERTIES may be animated.\n\t *\n\t * @param {THREE.AnimationClip} clip\n\t * @param {THREE.Object3D} root\n\t * @return {number|null}\n\t */\n\tprocessAnimation( clip, root ) {\n\n\t\tconst json = this.json;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tif ( ! json.animations ) json.animations = [];\n\n\t\tclip = GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );\n\n\t\tconst tracks = clip.tracks;\n\t\tconst channels = [];\n\t\tconst samplers = [];\n\n\t\tfor ( let i = 0; i < tracks.length; ++ i ) {\n\n\t\t\tconst track = tracks[ i ];\n\t\t\tconst trackBinding = PropertyBinding.parseTrackName( track.name );\n\t\t\tlet trackNode = PropertyBinding.findNode( root, trackBinding.nodeName );\n\t\t\tconst trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];\n\n\t\t\tif ( trackBinding.objectName === 'bones' ) {\n\n\t\t\t\tif ( trackNode.isSkinnedMesh === true ) {\n\n\t\t\t\t\ttrackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttrackNode = undefined;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! trackNode || ! trackProperty ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Could not export animation track \"%s\".', track.name );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tconst inputItemSize = 1;\n\t\t\tlet outputItemSize = track.values.length / track.times.length;\n\n\t\t\tif ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {\n\n\t\t\t\toutputItemSize /= trackNode.morphTargetInfluences.length;\n\n\t\t\t}\n\n\t\t\tlet interpolation;\n\n\t\t\t// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n\t\t\t// Detecting glTF cubic spline interpolant by checking factory method's special property\n\t\t\t// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n\t\t\t// valid value from .getInterpolation().\n\t\t\tif ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {\n\n\t\t\t\tinterpolation = 'CUBICSPLINE';\n\n\t\t\t\t// itemSize of CUBICSPLINE keyframe is 9\n\t\t\t\t// (VEC3 * 3: inTangent, splineVertex, and outTangent)\n\t\t\t\t// but needs to be stored as VEC3 so dividing by 3 here.\n\t\t\t\toutputItemSize /= 3;\n\n\t\t\t} else if ( track.getInterpolation() === InterpolateDiscrete ) {\n\n\t\t\t\tinterpolation = 'STEP';\n\n\t\t\t} else {\n\n\t\t\t\tinterpolation = 'LINEAR';\n\n\t\t\t}\n\n\t\t\tsamplers.push( {\n\t\t\t\tinput: this.processAccessor( new BufferAttribute( track.times, inputItemSize ) ),\n\t\t\t\toutput: this.processAccessor( new BufferAttribute( track.values, outputItemSize ) ),\n\t\t\t\tinterpolation: interpolation\n\t\t\t} );\n\n\t\t\tchannels.push( {\n\t\t\t\tsampler: samplers.length - 1,\n\t\t\t\ttarget: {\n\t\t\t\t\tnode: nodeMap.get( trackNode ),\n\t\t\t\t\tpath: trackProperty\n\t\t\t\t}\n\t\t\t} );\n\n\t\t}\n\n\t\tjson.animations.push( {\n\t\t\tname: clip.name || 'clip_' + json.animations.length,\n\t\t\tsamplers: samplers,\n\t\t\tchannels: channels\n\t\t} );\n\n\t\treturn json.animations.length - 1;\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D} object\n\t * @return {number|null}\n\t */\n\t processSkin( object ) {\n\n\t\tconst json = this.json;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tconst node = json.nodes[ nodeMap.get( object ) ];\n\n\t\tconst skeleton = object.skeleton;\n\n\t\tif ( skeleton === undefined ) return null;\n\n\t\tconst rootJoint = object.skeleton.bones[ 0 ];\n\n\t\tif ( rootJoint === undefined ) return null;\n\n\t\tconst joints = [];\n\t\tconst inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );\n\t\tconst temporaryBoneInverse = new Matrix4();\n\n\t\tfor ( let i = 0; i < skeleton.bones.length; ++ i ) {\n\n\t\t\tjoints.push( nodeMap.get( skeleton.bones[ i ] ) );\n\t\t\ttemporaryBoneInverse.copy( skeleton.boneInverses[ i ] );\n\t\t\ttemporaryBoneInverse.multiply( object.bindMatrix ).toArray( inverseBindMatrices, i * 16 );\n\n\t\t}\n\n\t\tif ( json.skins === undefined ) json.skins = [];\n\n\t\tjson.skins.push( {\n\t\t\tinverseBindMatrices: this.processAccessor( new BufferAttribute( inverseBindMatrices, 16 ) ),\n\t\t\tjoints: joints,\n\t\t\tskeleton: nodeMap.get( rootJoint )\n\t\t} );\n\n\t\tconst skinIndex = node.skin = json.skins.length - 1;\n\n\t\treturn skinIndex;\n\n\t}\n\n\t/**\n\t * Process Object3D node\n\t * @param  {THREE.Object3D} node Object3D to processNode\n\t * @return {Integer} Index of the node in the nodes list\n\t */\n\tprocessNode( object ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tif ( ! json.nodes ) json.nodes = [];\n\n\t\tconst nodeDef = {};\n\n\t\tif ( options.trs ) {\n\n\t\t\tconst rotation = object.quaternion.toArray();\n\t\t\tconst position = object.position.toArray();\n\t\t\tconst scale = object.scale.toArray();\n\n\t\t\tif ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {\n\n\t\t\t\tnodeDef.rotation = rotation;\n\n\t\t\t}\n\n\t\t\tif ( ! equalArray( position, [ 0, 0, 0 ] ) ) {\n\n\t\t\t\tnodeDef.translation = position;\n\n\t\t\t}\n\n\t\t\tif ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {\n\n\t\t\t\tnodeDef.scale = scale;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( object.matrixAutoUpdate ) {\n\n\t\t\t\tobject.updateMatrix();\n\n\t\t\t}\n\n\t\t\tif ( isIdentityMatrix( object.matrix ) === false ) {\n\n\t\t\t\tnodeDef.matrix = object.matrix.elements;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// We don't export empty strings name because it represents no-name in Three.js.\n\t\tif ( object.name !== '' ) nodeDef.name = String( object.name );\n\n\t\tthis.serializeUserData( object, nodeDef );\n\n\t\tif ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\tconst meshIndex = this.processMesh( object );\n\n\t\t\tif ( meshIndex !== null ) nodeDef.mesh = meshIndex;\n\n\t\t} else if ( object.isCamera ) {\n\n\t\t\tnodeDef.camera = this.processCamera( object );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) this.skins.push( object );\n\n\t\tif ( object.children.length > 0 ) {\n\n\t\t\tconst children = [];\n\n\t\t\tfor ( let i = 0, l = object.children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = object.children[ i ];\n\n\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\t\tconst nodeIndex = this.processNode( child );\n\n\t\t\t\t\tif ( nodeIndex !== null ) children.push( nodeIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( children.length > 0 ) nodeDef.children = children;\n\n\t\t}\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.writeNode && ext.writeNode( object, nodeDef );\n\n\t\t} );\n\n\t\tconst nodeIndex = json.nodes.push( nodeDef ) - 1;\n\t\tnodeMap.set( object, nodeIndex );\n\t\treturn nodeIndex;\n\n\t}\n\n\t/**\n\t * Process Scene\n\t * @param  {Scene} node Scene to process\n\t */\n\tprocessScene( scene ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tif ( ! json.scenes ) {\n\n\t\t\tjson.scenes = [];\n\t\t\tjson.scene = 0;\n\n\t\t}\n\n\t\tconst sceneDef = {};\n\n\t\tif ( scene.name !== '' ) sceneDef.name = scene.name;\n\n\t\tjson.scenes.push( sceneDef );\n\n\t\tconst nodes = [];\n\n\t\tfor ( let i = 0, l = scene.children.length; i < l; i ++ ) {\n\n\t\t\tconst child = scene.children[ i ];\n\n\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\tconst nodeIndex = this.processNode( child );\n\n\t\t\t\tif ( nodeIndex !== null ) nodes.push( nodeIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( nodes.length > 0 ) sceneDef.nodes = nodes;\n\n\t\tthis.serializeUserData( scene, sceneDef );\n\n\t}\n\n\t/**\n\t * Creates a Scene to hold a list of objects and parse it\n\t * @param  {Array} objects List of objects to process\n\t */\n\tprocessObjects( objects ) {\n\n\t\tconst scene = new Scene();\n\t\tscene.name = 'AuxScene';\n\n\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t// We push directly to children instead of calling `add` to prevent\n\t\t\t// modify the .parent and break its original scene and hierarchy\n\t\t\tscene.children.push( objects[ i ] );\n\n\t\t}\n\n\t\tthis.processScene( scene );\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D|Array<THREE.Object3D>} input\n\t */\n\tprocessInput( input ) {\n\n\t\tconst options = this.options;\n\n\t\tinput = input instanceof Array ? input : [ input ];\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.beforeParse && ext.beforeParse( input );\n\n\t\t} );\n\n\t\tconst objectsWithoutScene = [];\n\n\t\tfor ( let i = 0; i < input.length; i ++ ) {\n\n\t\t\tif ( input[ i ] instanceof Scene ) {\n\n\t\t\t\tthis.processScene( input[ i ] );\n\n\t\t\t} else {\n\n\t\t\t\tobjectsWithoutScene.push( input[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( objectsWithoutScene.length > 0 ) this.processObjects( objectsWithoutScene );\n\n\t\tfor ( let i = 0; i < this.skins.length; ++ i ) {\n\n\t\t\tthis.processSkin( this.skins[ i ] );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < options.animations.length; ++ i ) {\n\n\t\t\tthis.processAnimation( options.animations[ i ], input[ 0 ] );\n\n\t\t}\n\n\t\tthis._invokeAll( function ( ext ) {\n\n\t\t\text.afterParse && ext.afterParse( input );\n\n\t\t} );\n\n\t}\n\n\t_invokeAll( func ) {\n\n\t\tfor ( let i = 0, il = this.plugins.length; i < il; i ++ ) {\n\n\t\t\tfunc( this.plugins[ i ] );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n */\nclass GLTFLightExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_lights_punctual';\n\n\t}\n\n\twriteNode( light, nodeDef ) {\n\n\t\tif ( ! light.isLight ) return;\n\n\t\tif ( ! light.isDirectionalLight && ! light.isPointLight && ! light.isSpotLight ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst writer = this.writer;\n\t\tconst json = writer.json;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst lightDef = {};\n\n\t\tif ( light.name ) lightDef.name = light.name;\n\n\t\tlightDef.color = light.color.toArray();\n\n\t\tlightDef.intensity = light.intensity;\n\n\t\tif ( light.isDirectionalLight ) {\n\n\t\t\tlightDef.type = 'directional';\n\n\t\t} else if ( light.isPointLight ) {\n\n\t\t\tlightDef.type = 'point';\n\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t} else if ( light.isSpotLight ) {\n\n\t\t\tlightDef.type = 'spot';\n\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t\tlightDef.spot = {};\n\t\t\tlightDef.spot.innerConeAngle = ( light.penumbra - 1.0 ) * light.angle * - 1.0;\n\t\t\tlightDef.spot.outerConeAngle = light.angle;\n\n\t\t}\n\n\t\tif ( light.decay !== undefined && light.decay !== 2 ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, '\n\t\t\t\t+ 'and expects light.decay=2.' );\n\n\t\t}\n\n\t\tif ( light.target\n\t\t\t\t&& ( light.target.parent !== light\n\t\t\t\t|| light.target.position.x !== 0\n\t\t\t\t|| light.target.position.y !== 0\n\t\t\t\t|| light.target.position.z !== - 1 ) ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, '\n\t\t\t\t+ 'make light.target a child of the light with position 0,0,-1.' );\n\n\t\t}\n\n\t\tif ( ! extensionsUsed[ this.name ] ) {\n\n\t\t\tjson.extensions = json.extensions || {};\n\t\t\tjson.extensions[ this.name ] = { lights: [] };\n\t\t\textensionsUsed[ this.name ] = true;\n\n\t\t}\n\n\t\tconst lights = json.extensions[ this.name ].lights;\n\t\tlights.push( lightDef );\n\n\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\tnodeDef.extensions[ this.name ] = { light: lights.length - 1 };\n\n\t}\n\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_unlit';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshBasicMaterial ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = {};\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n\n\t}\n\n}\n\n/**\n * Specular-Glossiness Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness\n */\nclass GLTFMaterialsPBRSpecularGlossiness {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_pbrSpecularGlossiness';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isGLTFSpecularGlossinessMaterial ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( materialDef.pbrMetallicRoughness.baseColorFactor ) {\n\n\t\t\textensionDef.diffuseFactor = materialDef.pbrMetallicRoughness.baseColorFactor;\n\n\t\t}\n\n\t\tconst specularFactor = [ 1, 1, 1 ];\n\t\tmaterial.specular.toArray( specularFactor, 0 );\n\t\textensionDef.specularFactor = specularFactor;\n\t\textensionDef.glossinessFactor = material.glossiness;\n\n\t\tif ( materialDef.pbrMetallicRoughness.baseColorTexture ) {\n\n\t\t\textensionDef.diffuseTexture = materialDef.pbrMetallicRoughness.baseColorTexture;\n\n\t\t}\n\n\t\tif ( material.specularMap ) {\n\n\t\t\tconst specularMapDef = { index: writer.processTexture( material.specularMap ) };\n\t\t\twriter.applyTextureTransform( specularMapDef, material.specularMap );\n\t\t\textensionDef.specularGlossinessTexture = specularMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n */\nclass GLTFMaterialsClearcoatExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_clearcoat';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.clearcoatFactor = material.clearcoat;\n\n\t\tif ( material.clearcoatMap ) {\n\n\t\t\tconst clearcoatMapDef = { index: writer.processTexture( material.clearcoatMap ) };\n\t\t\twriter.applyTextureTransform( clearcoatMapDef, material.clearcoatMap );\n\t\t\textensionDef.clearcoatTexture = clearcoatMapDef;\n\n\t\t}\n\n\t\textensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n\n\t\tif ( material.clearcoatRoughnessMap ) {\n\n\t\t\tconst clearcoatRoughnessMapDef = { index: writer.processTexture( material.clearcoatRoughnessMap ) };\n\t\t\twriter.applyTextureTransform( clearcoatRoughnessMapDef, material.clearcoatRoughnessMap );\n\t\t\textensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n\n\t\t}\n\n\t\tif ( material.clearcoatNormalMap ) {\n\n\t\t\tconst clearcoatNormalMapDef = { index: writer.processTexture( material.clearcoatNormalMap ) };\n\t\t\twriter.applyTextureTransform( clearcoatNormalMapDef, material.clearcoatNormalMap );\n\t\t\textensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\n\t}\n\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n */\nclass GLTFMaterialsIridescenceExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_iridescence';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.iridescenceFactor = material.iridescence;\n\n\t\tif ( material.iridescenceMap ) {\n\n\t\t\tconst iridescenceMapDef = { index: writer.processTexture( material.iridescenceMap ) };\n\t\t\twriter.applyTextureTransform( iridescenceMapDef, material.iridescenceMap );\n\t\t\textensionDef.iridescenceTexture = iridescenceMapDef;\n\n\t\t}\n\n\t\textensionDef.iridescenceIor = material.iridescenceIOR;\n\t\textensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[ 0 ];\n\t\textensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[ 1 ];\n\n\t\tif ( material.iridescenceThicknessMap ) {\n\n\t\t\tconst iridescenceThicknessMapDef = { index: writer.processTexture( material.iridescenceThicknessMap ) };\n\t\t\twriter.applyTextureTransform( iridescenceThicknessMapDef, material.iridescenceThicknessMap );\n\t\t\textensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n */\nclass GLTFMaterialsTransmissionExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_transmission';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.transmissionFactor = material.transmission;\n\n\t\tif ( material.transmissionMap ) {\n\n\t\t\tconst transmissionMapDef = { index: writer.processTexture( material.transmissionMap ) };\n\t\t\twriter.applyTextureTransform( transmissionMapDef, material.transmissionMap );\n\t\t\textensionDef.transmissionTexture = transmissionMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n */\nclass GLTFMaterialsVolumeExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_volume';\n\n\t}\n\n\twriteMaterial( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.thicknessFactor = material.thickness;\n\n\t\tif ( material.thicknessMap ) {\n\n\t\t\tconst thicknessMapDef = { index: writer.processTexture( material.thicknessMap ) };\n\t\t\twriter.applyTextureTransform( thicknessMapDef, material.thicknessMap );\n\t\t\textensionDef.thicknessTexture = thicknessMapDef;\n\n\t\t}\n\n\t\textensionDef.attenuationDistance = material.attenuationDistance;\n\t\textensionDef.attenuationColor = material.attenuationColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Static utility functions\n */\nGLTFExporter.Utils = {\n\n\tinsertKeyframe: function ( track, time ) {\n\n\t\tconst tolerance = 0.001; // 1ms\n\t\tconst valueSize = track.getValueSize();\n\n\t\tconst times = new track.TimeBufferType( track.times.length + 1 );\n\t\tconst values = new track.ValueBufferType( track.values.length + valueSize );\n\t\tconst interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );\n\n\t\tlet index;\n\n\t\tif ( track.times.length === 0 ) {\n\n\t\t\ttimes[ 0 ] = time;\n\n\t\t\tfor ( let i = 0; i < valueSize; i ++ ) {\n\n\t\t\t\tvalues[ i ] = 0;\n\n\t\t\t}\n\n\t\t\tindex = 0;\n\n\t\t} else if ( time < track.times[ 0 ] ) {\n\n\t\t\tif ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;\n\n\t\t\ttimes[ 0 ] = time;\n\t\t\ttimes.set( track.times, 1 );\n\n\t\t\tvalues.set( interpolant.evaluate( time ), 0 );\n\t\t\tvalues.set( track.values, valueSize );\n\n\t\t\tindex = 0;\n\n\t\t} else if ( time > track.times[ track.times.length - 1 ] ) {\n\n\t\t\tif ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {\n\n\t\t\t\treturn track.times.length - 1;\n\n\t\t\t}\n\n\t\t\ttimes[ times.length - 1 ] = time;\n\t\t\ttimes.set( track.times, 0 );\n\n\t\t\tvalues.set( track.values, 0 );\n\t\t\tvalues.set( interpolant.evaluate( time ), track.values.length );\n\n\t\t\tindex = times.length - 1;\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < track.times.length; i ++ ) {\n\n\t\t\t\tif ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;\n\n\t\t\t\tif ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {\n\n\t\t\t\t\ttimes.set( track.times.slice( 0, i + 1 ), 0 );\n\t\t\t\t\ttimes[ i + 1 ] = time;\n\t\t\t\t\ttimes.set( track.times.slice( i + 1 ), i + 2 );\n\n\t\t\t\t\tvalues.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );\n\t\t\t\t\tvalues.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );\n\t\t\t\t\tvalues.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );\n\n\t\t\t\t\tindex = i + 1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\ttrack.times = times;\n\t\ttrack.values = values;\n\n\t\treturn index;\n\n\t},\n\n\tmergeMorphTargetTracks: function ( clip, root ) {\n\n\t\tconst tracks = [];\n\t\tconst mergedTracks = {};\n\t\tconst sourceTracks = clip.tracks;\n\n\t\tfor ( let i = 0; i < sourceTracks.length; ++ i ) {\n\n\t\t\tlet sourceTrack = sourceTracks[ i ];\n\t\t\tconst sourceTrackBinding = PropertyBinding.parseTrackName( sourceTrack.name );\n\t\t\tconst sourceTrackNode = PropertyBinding.findNode( root, sourceTrackBinding.nodeName );\n\n\t\t\tif ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {\n\n\t\t\t\t// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n\t\t\t\ttracks.push( sourceTrack );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete\n\t\t\t\t&& sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {\n\n\t\t\t\tif ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\t\t\t// This should never happen, because glTF morph target animations\n\t\t\t\t\t// affect all targets already.\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );\n\n\t\t\t\tsourceTrack = sourceTrack.clone();\n\t\t\t\tsourceTrack.setInterpolation( InterpolateLinear );\n\n\t\t\t}\n\n\t\t\tconst targetCount = sourceTrackNode.morphTargetInfluences.length;\n\t\t\tconst targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];\n\n\t\t\tif ( targetIndex === undefined ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );\n\n\t\t\t}\n\n\t\t\tlet mergedTrack;\n\n\t\t\t// If this is the first time we've seen this object, create a new\n\t\t\t// track to store merged keyframe data for each morph target.\n\t\t\tif ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {\n\n\t\t\t\tmergedTrack = sourceTrack.clone();\n\n\t\t\t\tconst values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );\n\n\t\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\t\tvalues[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];\n\n\t\t\t\t}\n\n\t\t\t\t// We need to take into consideration the intended target node\n\t\t\t\t// of our original un-merged morphTarget animation.\n\t\t\t\tmergedTrack.name = ( sourceTrackBinding.nodeName || '' ) + '.morphTargetInfluences';\n\t\t\t\tmergedTrack.values = values;\n\n\t\t\t\tmergedTracks[ sourceTrackNode.uuid ] = mergedTrack;\n\t\t\t\ttracks.push( mergedTrack );\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );\n\n\t\t\tmergedTrack = mergedTracks[ sourceTrackNode.uuid ];\n\n\t\t\t// For every existing keyframe of the merged track, write a (possibly\n\t\t\t// interpolated) value from the source track.\n\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\tmergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );\n\n\t\t\t}\n\n\t\t\t// For every existing keyframe of the source track, write a (possibly\n\t\t\t// new) keyframe to the merged track. Values from the previous loop may\n\t\t\t// be written again, but keyframes are de-duplicated.\n\t\t\tfor ( let j = 0; j < sourceTrack.times.length; j ++ ) {\n\n\t\t\t\tconst keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );\n\t\t\t\tmergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tclip.tracks = tracks;\n\n\t\treturn clip;\n\n\t}\n\n};\n\nexport { GLTFExporter };\n"],
  "mappings": "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",
  "names": []
}
