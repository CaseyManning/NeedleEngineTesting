{
  "version": 3,
  "sources": ["../../../../Library/PackageCache/com.needle.engine@2.7.3-pre/package~/node_modules/flatbuffers/mjs/constants.js", "../../../../Library/PackageCache/com.needle.engine@2.7.3-pre/package~/node_modules/flatbuffers/mjs/utils.js", "../../../../Library/PackageCache/com.needle.engine@2.7.3-pre/package~/node_modules/flatbuffers/mjs/long.js", "../../../../Library/PackageCache/com.needle.engine@2.7.3-pre/package~/node_modules/flatbuffers/mjs/encoding.js", "../../../../Library/PackageCache/com.needle.engine@2.7.3-pre/package~/node_modules/flatbuffers/mjs/byte-buffer.js", "../../../../Library/PackageCache/com.needle.engine@2.7.3-pre/package~/node_modules/flatbuffers/mjs/builder.js"],
  "sourcesContent": ["export const SIZEOF_SHORT = 2;\r\nexport const SIZEOF_INT = 4;\r\nexport const FILE_IDENTIFIER_LENGTH = 4;\r\nexport const SIZE_PREFIX_LENGTH = 4;\r\n", "export const int32 = new Int32Array(2);\r\nexport const float32 = new Float32Array(int32.buffer);\r\nexport const float64 = new Float64Array(int32.buffer);\r\nexport const isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;\r\n", "export function createLong(low, high) {\r\n    return Long.create(low, high);\r\n}\r\nexport class Long {\r\n    constructor(low, high) {\r\n        this.low = low | 0;\r\n        this.high = high | 0;\r\n    }\r\n    static create(low, high) {\r\n        // Special-case zero to avoid GC overhead for default values\r\n        return low == 0 && high == 0 ? Long.ZERO : new Long(low, high);\r\n    }\r\n    toFloat64() {\r\n        return (this.low >>> 0) + this.high * 0x100000000;\r\n    }\r\n    equals(other) {\r\n        return this.low == other.low && this.high == other.high;\r\n    }\r\n}\r\nLong.ZERO = new Long(0, 0);\r\n", "export var Encoding;\r\n(function (Encoding) {\r\n    Encoding[Encoding[\"UTF8_BYTES\"] = 1] = \"UTF8_BYTES\";\r\n    Encoding[Encoding[\"UTF16_STRING\"] = 2] = \"UTF16_STRING\";\r\n})(Encoding || (Encoding = {}));\r\n", "import { FILE_IDENTIFIER_LENGTH, SIZEOF_INT } from \"./constants\";\r\nimport { Long } from \"./long\";\r\nimport { int32, isLittleEndian, float32, float64 } from \"./utils\";\r\nimport { Encoding } from \"./encoding\";\r\nexport class ByteBuffer {\r\n    /**\r\n     * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)\r\n     */\r\n    constructor(bytes_) {\r\n        this.bytes_ = bytes_;\r\n        this.position_ = 0;\r\n    }\r\n    /**\r\n     * Create and allocate a new ByteBuffer with a given size.\r\n     */\r\n    static allocate(byte_size) {\r\n        return new ByteBuffer(new Uint8Array(byte_size));\r\n    }\r\n    clear() {\r\n        this.position_ = 0;\r\n    }\r\n    /**\r\n     * Get the underlying `Uint8Array`.\r\n     */\r\n    bytes() {\r\n        return this.bytes_;\r\n    }\r\n    /**\r\n     * Get the buffer's position.\r\n     */\r\n    position() {\r\n        return this.position_;\r\n    }\r\n    /**\r\n     * Set the buffer's position.\r\n     */\r\n    setPosition(position) {\r\n        this.position_ = position;\r\n    }\r\n    /**\r\n     * Get the buffer's capacity.\r\n     */\r\n    capacity() {\r\n        return this.bytes_.length;\r\n    }\r\n    readInt8(offset) {\r\n        return this.readUint8(offset) << 24 >> 24;\r\n    }\r\n    readUint8(offset) {\r\n        return this.bytes_[offset];\r\n    }\r\n    readInt16(offset) {\r\n        return this.readUint16(offset) << 16 >> 16;\r\n    }\r\n    readUint16(offset) {\r\n        return this.bytes_[offset] | this.bytes_[offset + 1] << 8;\r\n    }\r\n    readInt32(offset) {\r\n        return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;\r\n    }\r\n    readUint32(offset) {\r\n        return this.readInt32(offset) >>> 0;\r\n    }\r\n    readInt64(offset) {\r\n        return new Long(this.readInt32(offset), this.readInt32(offset + 4));\r\n    }\r\n    readUint64(offset) {\r\n        return new Long(this.readUint32(offset), this.readUint32(offset + 4));\r\n    }\r\n    readFloat32(offset) {\r\n        int32[0] = this.readInt32(offset);\r\n        return float32[0];\r\n    }\r\n    readFloat64(offset) {\r\n        int32[isLittleEndian ? 0 : 1] = this.readInt32(offset);\r\n        int32[isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);\r\n        return float64[0];\r\n    }\r\n    writeInt8(offset, value) {\r\n        this.bytes_[offset] = value;\r\n    }\r\n    writeUint8(offset, value) {\r\n        this.bytes_[offset] = value;\r\n    }\r\n    writeInt16(offset, value) {\r\n        this.bytes_[offset] = value;\r\n        this.bytes_[offset + 1] = value >> 8;\r\n    }\r\n    writeUint16(offset, value) {\r\n        this.bytes_[offset] = value;\r\n        this.bytes_[offset + 1] = value >> 8;\r\n    }\r\n    writeInt32(offset, value) {\r\n        this.bytes_[offset] = value;\r\n        this.bytes_[offset + 1] = value >> 8;\r\n        this.bytes_[offset + 2] = value >> 16;\r\n        this.bytes_[offset + 3] = value >> 24;\r\n    }\r\n    writeUint32(offset, value) {\r\n        this.bytes_[offset] = value;\r\n        this.bytes_[offset + 1] = value >> 8;\r\n        this.bytes_[offset + 2] = value >> 16;\r\n        this.bytes_[offset + 3] = value >> 24;\r\n    }\r\n    writeInt64(offset, value) {\r\n        this.writeInt32(offset, value.low);\r\n        this.writeInt32(offset + 4, value.high);\r\n    }\r\n    writeUint64(offset, value) {\r\n        this.writeUint32(offset, value.low);\r\n        this.writeUint32(offset + 4, value.high);\r\n    }\r\n    writeFloat32(offset, value) {\r\n        float32[0] = value;\r\n        this.writeInt32(offset, int32[0]);\r\n    }\r\n    writeFloat64(offset, value) {\r\n        float64[0] = value;\r\n        this.writeInt32(offset, int32[isLittleEndian ? 0 : 1]);\r\n        this.writeInt32(offset + 4, int32[isLittleEndian ? 1 : 0]);\r\n    }\r\n    /**\r\n     * Return the file identifier.   Behavior is undefined for FlatBuffers whose\r\n     * schema does not include a file_identifier (likely points at padding or the\r\n     * start of a the root vtable).\r\n     */\r\n    getBufferIdentifier() {\r\n        if (this.bytes_.length < this.position_ + SIZEOF_INT +\r\n            FILE_IDENTIFIER_LENGTH) {\r\n            throw new Error('FlatBuffers: ByteBuffer is too short to contain an identifier.');\r\n        }\r\n        let result = \"\";\r\n        for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\r\n            result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i));\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Look up a field in the vtable, return an offset into the object, or 0 if the\r\n     * field is not present.\r\n     */\r\n    __offset(bb_pos, vtable_offset) {\r\n        const vtable = bb_pos - this.readInt32(bb_pos);\r\n        return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;\r\n    }\r\n    /**\r\n     * Initialize any Table-derived type to point to the union at the given offset.\r\n     */\r\n    __union(t, offset) {\r\n        t.bb_pos = offset + this.readInt32(offset);\r\n        t.bb = this;\r\n        return t;\r\n    }\r\n    /**\r\n     * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.\r\n     * This allocates a new string and converts to wide chars upon each access.\r\n     *\r\n     * To avoid the conversion to UTF-16, pass Encoding.UTF8_BYTES as\r\n     * the \"optionalEncoding\" argument. This is useful for avoiding conversion to\r\n     * and from UTF-16 when the data will just be packaged back up in another\r\n     * FlatBuffer later on.\r\n     *\r\n     * @param offset\r\n     * @param opt_encoding Defaults to UTF16_STRING\r\n     */\r\n    __string(offset, opt_encoding) {\r\n        offset += this.readInt32(offset);\r\n        const length = this.readInt32(offset);\r\n        let result = '';\r\n        let i = 0;\r\n        offset += SIZEOF_INT;\r\n        if (opt_encoding === Encoding.UTF8_BYTES) {\r\n            return this.bytes_.subarray(offset, offset + length);\r\n        }\r\n        while (i < length) {\r\n            let codePoint;\r\n            // Decode UTF-8\r\n            const a = this.readUint8(offset + i++);\r\n            if (a < 0xC0) {\r\n                codePoint = a;\r\n            }\r\n            else {\r\n                const b = this.readUint8(offset + i++);\r\n                if (a < 0xE0) {\r\n                    codePoint =\r\n                        ((a & 0x1F) << 6) |\r\n                            (b & 0x3F);\r\n                }\r\n                else {\r\n                    const c = this.readUint8(offset + i++);\r\n                    if (a < 0xF0) {\r\n                        codePoint =\r\n                            ((a & 0x0F) << 12) |\r\n                                ((b & 0x3F) << 6) |\r\n                                (c & 0x3F);\r\n                    }\r\n                    else {\r\n                        const d = this.readUint8(offset + i++);\r\n                        codePoint =\r\n                            ((a & 0x07) << 18) |\r\n                                ((b & 0x3F) << 12) |\r\n                                ((c & 0x3F) << 6) |\r\n                                (d & 0x3F);\r\n                    }\r\n                }\r\n            }\r\n            // Encode UTF-16\r\n            if (codePoint < 0x10000) {\r\n                result += String.fromCharCode(codePoint);\r\n            }\r\n            else {\r\n                codePoint -= 0x10000;\r\n                result += String.fromCharCode((codePoint >> 10) + 0xD800, (codePoint & ((1 << 10) - 1)) + 0xDC00);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Handle unions that can contain string as its member, if a Table-derived type then initialize it,\r\n     * if a string then return a new one\r\n     *\r\n     * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this\r\n     * makes the behaviour of __union_with_string different compared to __union\r\n     */\r\n    __union_with_string(o, offset) {\r\n        if (typeof o === 'string') {\r\n            return this.__string(offset);\r\n        }\r\n        return this.__union(o, offset);\r\n    }\r\n    /**\r\n     * Retrieve the relative offset stored at \"offset\"\r\n     */\r\n    __indirect(offset) {\r\n        return offset + this.readInt32(offset);\r\n    }\r\n    /**\r\n     * Get the start of data of a vector whose offset is stored at \"offset\" in this object.\r\n     */\r\n    __vector(offset) {\r\n        return offset + this.readInt32(offset) + SIZEOF_INT; // data starts after the length\r\n    }\r\n    /**\r\n     * Get the length of a vector whose offset is stored at \"offset\" in this object.\r\n     */\r\n    __vector_len(offset) {\r\n        return this.readInt32(offset + this.readInt32(offset));\r\n    }\r\n    __has_identifier(ident) {\r\n        if (ident.length != FILE_IDENTIFIER_LENGTH) {\r\n            throw new Error('FlatBuffers: file identifier must be length ' +\r\n                FILE_IDENTIFIER_LENGTH);\r\n        }\r\n        for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {\r\n            if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * A helper function to avoid generated code depending on this file directly.\r\n     */\r\n    createLong(low, high) {\r\n        return Long.create(low, high);\r\n    }\r\n    /**\r\n     * A helper function for generating list for obj api\r\n     */\r\n    createScalarList(listAccessor, listLength) {\r\n        const ret = [];\r\n        for (let i = 0; i < listLength; ++i) {\r\n            if (listAccessor(i) !== null) {\r\n                ret.push(listAccessor(i));\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    /**\r\n     * A helper function for generating list for obj api\r\n     * @param listAccessor function that accepts an index and return data at that index\r\n     * @param listLength listLength\r\n     * @param res result list\r\n     */\r\n    createObjList(listAccessor, listLength) {\r\n        const ret = [];\r\n        for (let i = 0; i < listLength; ++i) {\r\n            const val = listAccessor(i);\r\n            if (val !== null) {\r\n                ret.push(val.unpack());\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n", "import { ByteBuffer } from \"./byte-buffer\";\r\nimport { SIZEOF_SHORT, SIZE_PREFIX_LENGTH, SIZEOF_INT, FILE_IDENTIFIER_LENGTH } from \"./constants\";\r\nimport { Long } from \"./long\";\r\nexport class Builder {\r\n    /**\r\n     * Create a FlatBufferBuilder.\r\n     */\r\n    constructor(opt_initial_size) {\r\n        /** Minimum alignment encountered so far. */\r\n        this.minalign = 1;\r\n        /** The vtable for the current table. */\r\n        this.vtable = null;\r\n        /** The amount of fields we're actually using. */\r\n        this.vtable_in_use = 0;\r\n        /** Whether we are currently serializing a table. */\r\n        this.isNested = false;\r\n        /** Starting offset of the current struct/table. */\r\n        this.object_start = 0;\r\n        /** List of offsets of all vtables. */\r\n        this.vtables = [];\r\n        /** For the current vector being built. */\r\n        this.vector_num_elems = 0;\r\n        /** False omits default values from the serialized data */\r\n        this.force_defaults = false;\r\n        this.string_maps = null;\r\n        let initial_size;\r\n        if (!opt_initial_size) {\r\n            initial_size = 1024;\r\n        }\r\n        else {\r\n            initial_size = opt_initial_size;\r\n        }\r\n        /**\r\n         * @type {ByteBuffer}\r\n         * @private\r\n         */\r\n        this.bb = ByteBuffer.allocate(initial_size);\r\n        this.space = initial_size;\r\n    }\r\n    clear() {\r\n        this.bb.clear();\r\n        this.space = this.bb.capacity();\r\n        this.minalign = 1;\r\n        this.vtable = null;\r\n        this.vtable_in_use = 0;\r\n        this.isNested = false;\r\n        this.object_start = 0;\r\n        this.vtables = [];\r\n        this.vector_num_elems = 0;\r\n        this.force_defaults = false;\r\n        this.string_maps = null;\r\n    }\r\n    /**\r\n     * In order to save space, fields that are set to their default value\r\n     * don't get serialized into the buffer. Forcing defaults provides a\r\n     * way to manually disable this optimization.\r\n     *\r\n     * @param forceDefaults true always serializes default values\r\n     */\r\n    forceDefaults(forceDefaults) {\r\n        this.force_defaults = forceDefaults;\r\n    }\r\n    /**\r\n     * Get the ByteBuffer representing the FlatBuffer. Only call this after you've\r\n     * called finish(). The actual data starts at the ByteBuffer's current position,\r\n     * not necessarily at 0.\r\n     */\r\n    dataBuffer() {\r\n        return this.bb;\r\n    }\r\n    /**\r\n     * Get the bytes representing the FlatBuffer. Only call this after you've\r\n     * called finish().\r\n     */\r\n    asUint8Array() {\r\n        return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());\r\n    }\r\n    /**\r\n     * Prepare to write an element of `size` after `additional_bytes` have been\r\n     * written, e.g. if you write a string, you need to align such the int length\r\n     * field is aligned to 4 bytes, and the string data follows it directly. If all\r\n     * you need to do is alignment, `additional_bytes` will be 0.\r\n     *\r\n     * @param size This is the of the new element to write\r\n     * @param additional_bytes The padding size\r\n     */\r\n    prep(size, additional_bytes) {\r\n        // Track the biggest thing we've ever aligned to.\r\n        if (size > this.minalign) {\r\n            this.minalign = size;\r\n        }\r\n        // Find the amount of alignment needed such that `size` is properly\r\n        // aligned after `additional_bytes`\r\n        const align_size = ((~(this.bb.capacity() - this.space + additional_bytes)) + 1) & (size - 1);\r\n        // Reallocate the buffer if needed.\r\n        while (this.space < align_size + size + additional_bytes) {\r\n            const old_buf_size = this.bb.capacity();\r\n            this.bb = Builder.growByteBuffer(this.bb);\r\n            this.space += this.bb.capacity() - old_buf_size;\r\n        }\r\n        this.pad(align_size);\r\n    }\r\n    pad(byte_size) {\r\n        for (let i = 0; i < byte_size; i++) {\r\n            this.bb.writeInt8(--this.space, 0);\r\n        }\r\n    }\r\n    writeInt8(value) {\r\n        this.bb.writeInt8(this.space -= 1, value);\r\n    }\r\n    writeInt16(value) {\r\n        this.bb.writeInt16(this.space -= 2, value);\r\n    }\r\n    writeInt32(value) {\r\n        this.bb.writeInt32(this.space -= 4, value);\r\n    }\r\n    writeInt64(value) {\r\n        this.bb.writeInt64(this.space -= 8, value);\r\n    }\r\n    writeFloat32(value) {\r\n        this.bb.writeFloat32(this.space -= 4, value);\r\n    }\r\n    writeFloat64(value) {\r\n        this.bb.writeFloat64(this.space -= 8, value);\r\n    }\r\n    /**\r\n     * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).\r\n     * @param value The `int8` to add the the buffer.\r\n     */\r\n    addInt8(value) {\r\n        this.prep(1, 0);\r\n        this.writeInt8(value);\r\n    }\r\n    /**\r\n     * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).\r\n     * @param value The `int16` to add the the buffer.\r\n     */\r\n    addInt16(value) {\r\n        this.prep(2, 0);\r\n        this.writeInt16(value);\r\n    }\r\n    /**\r\n     * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).\r\n     * @param value The `int32` to add the the buffer.\r\n     */\r\n    addInt32(value) {\r\n        this.prep(4, 0);\r\n        this.writeInt32(value);\r\n    }\r\n    /**\r\n     * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).\r\n     * @param value The `int64` to add the the buffer.\r\n     */\r\n    addInt64(value) {\r\n        this.prep(8, 0);\r\n        this.writeInt64(value);\r\n    }\r\n    /**\r\n     * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).\r\n     * @param value The `float32` to add the the buffer.\r\n     */\r\n    addFloat32(value) {\r\n        this.prep(4, 0);\r\n        this.writeFloat32(value);\r\n    }\r\n    /**\r\n     * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).\r\n     * @param value The `float64` to add the the buffer.\r\n     */\r\n    addFloat64(value) {\r\n        this.prep(8, 0);\r\n        this.writeFloat64(value);\r\n    }\r\n    addFieldInt8(voffset, value, defaultValue) {\r\n        if (this.force_defaults || value != defaultValue) {\r\n            this.addInt8(value);\r\n            this.slot(voffset);\r\n        }\r\n    }\r\n    addFieldInt16(voffset, value, defaultValue) {\r\n        if (this.force_defaults || value != defaultValue) {\r\n            this.addInt16(value);\r\n            this.slot(voffset);\r\n        }\r\n    }\r\n    addFieldInt32(voffset, value, defaultValue) {\r\n        if (this.force_defaults || value != defaultValue) {\r\n            this.addInt32(value);\r\n            this.slot(voffset);\r\n        }\r\n    }\r\n    addFieldInt64(voffset, value, defaultValue) {\r\n        if (this.force_defaults || !value.equals(defaultValue)) {\r\n            this.addInt64(value);\r\n            this.slot(voffset);\r\n        }\r\n    }\r\n    addFieldFloat32(voffset, value, defaultValue) {\r\n        if (this.force_defaults || value != defaultValue) {\r\n            this.addFloat32(value);\r\n            this.slot(voffset);\r\n        }\r\n    }\r\n    addFieldFloat64(voffset, value, defaultValue) {\r\n        if (this.force_defaults || value != defaultValue) {\r\n            this.addFloat64(value);\r\n            this.slot(voffset);\r\n        }\r\n    }\r\n    addFieldOffset(voffset, value, defaultValue) {\r\n        if (this.force_defaults || value != defaultValue) {\r\n            this.addOffset(value);\r\n            this.slot(voffset);\r\n        }\r\n    }\r\n    /**\r\n     * Structs are stored inline, so nothing additional is being added. `d` is always 0.\r\n     */\r\n    addFieldStruct(voffset, value, defaultValue) {\r\n        if (value != defaultValue) {\r\n            this.nested(value);\r\n            this.slot(voffset);\r\n        }\r\n    }\r\n    /**\r\n     * Structures are always stored inline, they need to be created right\r\n     * where they're used.  You'll get this assertion failure if you\r\n     * created it elsewhere.\r\n     */\r\n    nested(obj) {\r\n        if (obj != this.offset()) {\r\n            throw new Error('FlatBuffers: struct must be serialized inline.');\r\n        }\r\n    }\r\n    /**\r\n     * Should not be creating any other object, string or vector\r\n     * while an object is being constructed\r\n     */\r\n    notNested() {\r\n        if (this.isNested) {\r\n            throw new Error('FlatBuffers: object serialization must not be nested.');\r\n        }\r\n    }\r\n    /**\r\n     * Set the current vtable at `voffset` to the current location in the buffer.\r\n     */\r\n    slot(voffset) {\r\n        if (this.vtable !== null)\r\n            this.vtable[voffset] = this.offset();\r\n    }\r\n    /**\r\n     * @returns Offset relative to the end of the buffer.\r\n     */\r\n    offset() {\r\n        return this.bb.capacity() - this.space;\r\n    }\r\n    /**\r\n     * Doubles the size of the backing ByteBuffer and copies the old data towards\r\n     * the end of the new buffer (since we build the buffer backwards).\r\n     *\r\n     * @param bb The current buffer with the existing data\r\n     * @returns A new byte buffer with the old data copied\r\n     * to it. The data is located at the end of the buffer.\r\n     *\r\n     * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass\r\n     * it a uint8Array we need to suppress the type check:\r\n     * @suppress {checkTypes}\r\n     */\r\n    static growByteBuffer(bb) {\r\n        const old_buf_size = bb.capacity();\r\n        // Ensure we don't grow beyond what fits in an int.\r\n        if (old_buf_size & 0xC0000000) {\r\n            throw new Error('FlatBuffers: cannot grow buffer beyond 2 gigabytes.');\r\n        }\r\n        const new_buf_size = old_buf_size << 1;\r\n        const nbb = ByteBuffer.allocate(new_buf_size);\r\n        nbb.setPosition(new_buf_size - old_buf_size);\r\n        nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);\r\n        return nbb;\r\n    }\r\n    /**\r\n     * Adds on offset, relative to where it will be written.\r\n     *\r\n     * @param offset The offset to add.\r\n     */\r\n    addOffset(offset) {\r\n        this.prep(SIZEOF_INT, 0); // Ensure alignment is already done.\r\n        this.writeInt32(this.offset() - offset + SIZEOF_INT);\r\n    }\r\n    /**\r\n     * Start encoding a new object in the buffer.  Users will not usually need to\r\n     * call this directly. The FlatBuffers compiler will generate helper methods\r\n     * that call this method internally.\r\n     */\r\n    startObject(numfields) {\r\n        this.notNested();\r\n        if (this.vtable == null) {\r\n            this.vtable = [];\r\n        }\r\n        this.vtable_in_use = numfields;\r\n        for (let i = 0; i < numfields; i++) {\r\n            this.vtable[i] = 0; // This will push additional elements as needed\r\n        }\r\n        this.isNested = true;\r\n        this.object_start = this.offset();\r\n    }\r\n    /**\r\n     * Finish off writing the object that is under construction.\r\n     *\r\n     * @returns The offset to the object inside `dataBuffer`\r\n     */\r\n    endObject() {\r\n        if (this.vtable == null || !this.isNested) {\r\n            throw new Error('FlatBuffers: endObject called without startObject');\r\n        }\r\n        this.addInt32(0);\r\n        const vtableloc = this.offset();\r\n        // Trim trailing zeroes.\r\n        let i = this.vtable_in_use - 1;\r\n        // eslint-disable-next-line no-empty\r\n        for (; i >= 0 && this.vtable[i] == 0; i--) { }\r\n        const trimmed_size = i + 1;\r\n        // Write out the current vtable.\r\n        for (; i >= 0; i--) {\r\n            // Offset relative to the start of the table.\r\n            this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);\r\n        }\r\n        const standard_fields = 2; // The fields below:\r\n        this.addInt16(vtableloc - this.object_start);\r\n        const len = (trimmed_size + standard_fields) * SIZEOF_SHORT;\r\n        this.addInt16(len);\r\n        // Search for an existing vtable that matches the current one.\r\n        let existing_vtable = 0;\r\n        const vt1 = this.space;\r\n        outer_loop: for (i = 0; i < this.vtables.length; i++) {\r\n            const vt2 = this.bb.capacity() - this.vtables[i];\r\n            if (len == this.bb.readInt16(vt2)) {\r\n                for (let j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {\r\n                    if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {\r\n                        continue outer_loop;\r\n                    }\r\n                }\r\n                existing_vtable = this.vtables[i];\r\n                break;\r\n            }\r\n        }\r\n        if (existing_vtable) {\r\n            // Found a match:\r\n            // Remove the current vtable.\r\n            this.space = this.bb.capacity() - vtableloc;\r\n            // Point table to existing vtable.\r\n            this.bb.writeInt32(this.space, existing_vtable - vtableloc);\r\n        }\r\n        else {\r\n            // No match:\r\n            // Add the location of the current vtable to the list of vtables.\r\n            this.vtables.push(this.offset());\r\n            // Point table to current vtable.\r\n            this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);\r\n        }\r\n        this.isNested = false;\r\n        return vtableloc;\r\n    }\r\n    /**\r\n     * Finalize a buffer, poiting to the given `root_table`.\r\n     */\r\n    finish(root_table, opt_file_identifier, opt_size_prefix) {\r\n        const size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;\r\n        if (opt_file_identifier) {\r\n            const file_identifier = opt_file_identifier;\r\n            this.prep(this.minalign, SIZEOF_INT +\r\n                FILE_IDENTIFIER_LENGTH + size_prefix);\r\n            if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {\r\n                throw new Error('FlatBuffers: file identifier must be length ' +\r\n                    FILE_IDENTIFIER_LENGTH);\r\n            }\r\n            for (let i = FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {\r\n                this.writeInt8(file_identifier.charCodeAt(i));\r\n            }\r\n        }\r\n        this.prep(this.minalign, SIZEOF_INT + size_prefix);\r\n        this.addOffset(root_table);\r\n        if (size_prefix) {\r\n            this.addInt32(this.bb.capacity() - this.space);\r\n        }\r\n        this.bb.setPosition(this.space);\r\n    }\r\n    /**\r\n     * Finalize a size prefixed buffer, pointing to the given `root_table`.\r\n     */\r\n    finishSizePrefixed(root_table, opt_file_identifier) {\r\n        this.finish(root_table, opt_file_identifier, true);\r\n    }\r\n    /**\r\n     * This checks a required field has been set in a given table that has\r\n     * just been constructed.\r\n     */\r\n    requiredField(table, field) {\r\n        const table_start = this.bb.capacity() - table;\r\n        const vtable_start = table_start - this.bb.readInt32(table_start);\r\n        const ok = this.bb.readInt16(vtable_start + field) != 0;\r\n        // If this fails, the caller will show what field needs to be set.\r\n        if (!ok) {\r\n            throw new Error('FlatBuffers: field ' + field + ' must be set');\r\n        }\r\n    }\r\n    /**\r\n     * Start a new array/vector of objects.  Users usually will not call\r\n     * this directly. The FlatBuffers compiler will create a start/end\r\n     * method for vector types in generated code.\r\n     *\r\n     * @param elem_size The size of each element in the array\r\n     * @param num_elems The number of elements in the array\r\n     * @param alignment The alignment of the array\r\n     */\r\n    startVector(elem_size, num_elems, alignment) {\r\n        this.notNested();\r\n        this.vector_num_elems = num_elems;\r\n        this.prep(SIZEOF_INT, elem_size * num_elems);\r\n        this.prep(alignment, elem_size * num_elems); // Just in case alignment > int.\r\n    }\r\n    /**\r\n     * Finish off the creation of an array and all its elements. The array must be\r\n     * created with `startVector`.\r\n     *\r\n     * @returns The offset at which the newly created array\r\n     * starts.\r\n     */\r\n    endVector() {\r\n        this.writeInt32(this.vector_num_elems);\r\n        return this.offset();\r\n    }\r\n    /**\r\n     * Encode the string `s` in the buffer using UTF-8. If the string passed has\r\n     * already been seen, we return the offset of the already written string\r\n     *\r\n     * @param s The string to encode\r\n     * @return The offset in the buffer where the encoded string starts\r\n     */\r\n    createSharedString(s) {\r\n        if (!s) {\r\n            return 0;\r\n        }\r\n        if (!this.string_maps) {\r\n            this.string_maps = new Map();\r\n        }\r\n        if (this.string_maps.has(s)) {\r\n            return this.string_maps.get(s);\r\n        }\r\n        const offset = this.createString(s);\r\n        this.string_maps.set(s, offset);\r\n        return offset;\r\n    }\r\n    /**\r\n     * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed\r\n     * instead of a string, it is assumed to contain valid UTF-8 encoded data.\r\n     *\r\n     * @param s The string to encode\r\n     * @return The offset in the buffer where the encoded string starts\r\n     */\r\n    createString(s) {\r\n        if (!s) {\r\n            return 0;\r\n        }\r\n        let utf8;\r\n        if (s instanceof Uint8Array) {\r\n            utf8 = s;\r\n        }\r\n        else {\r\n            utf8 = [];\r\n            let i = 0;\r\n            while (i < s.length) {\r\n                let codePoint;\r\n                // Decode UTF-16\r\n                const a = s.charCodeAt(i++);\r\n                if (a < 0xD800 || a >= 0xDC00) {\r\n                    codePoint = a;\r\n                }\r\n                else {\r\n                    const b = s.charCodeAt(i++);\r\n                    codePoint = (a << 10) + b + (0x10000 - (0xD800 << 10) - 0xDC00);\r\n                }\r\n                // Encode UTF-8\r\n                if (codePoint < 0x80) {\r\n                    utf8.push(codePoint);\r\n                }\r\n                else {\r\n                    if (codePoint < 0x800) {\r\n                        utf8.push(((codePoint >> 6) & 0x1F) | 0xC0);\r\n                    }\r\n                    else {\r\n                        if (codePoint < 0x10000) {\r\n                            utf8.push(((codePoint >> 12) & 0x0F) | 0xE0);\r\n                        }\r\n                        else {\r\n                            utf8.push(((codePoint >> 18) & 0x07) | 0xF0, ((codePoint >> 12) & 0x3F) | 0x80);\r\n                        }\r\n                        utf8.push(((codePoint >> 6) & 0x3F) | 0x80);\r\n                    }\r\n                    utf8.push((codePoint & 0x3F) | 0x80);\r\n                }\r\n            }\r\n        }\r\n        this.addInt8(0);\r\n        this.startVector(1, utf8.length, 1);\r\n        this.bb.setPosition(this.space -= utf8.length);\r\n        for (let i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {\r\n            bytes[offset++] = utf8[i];\r\n        }\r\n        return this.endVector();\r\n    }\r\n    /**\r\n     * A helper function to avoid generated code depending on this file directly.\r\n     */\r\n    createLong(low, high) {\r\n        return Long.create(low, high);\r\n    }\r\n    /**\r\n     * A helper function to pack an object\r\n     *\r\n     * @returns offset of obj\r\n     */\r\n    createObjectOffset(obj) {\r\n        if (obj === null) {\r\n            return 0;\r\n        }\r\n        if (typeof obj === 'string') {\r\n            return this.createString(obj);\r\n        }\r\n        else {\r\n            return obj.pack(this);\r\n        }\r\n    }\r\n    /**\r\n     * A helper function to pack a list of object\r\n     *\r\n     * @returns list of offsets of each non null object\r\n     */\r\n    createObjectOffsetList(list) {\r\n        const ret = [];\r\n        for (let i = 0; i < list.length; ++i) {\r\n            const val = list[i];\r\n            if (val !== null) {\r\n                ret.push(this.createObjectOffset(val));\r\n            }\r\n            else {\r\n                throw new Error('FlatBuffers: Argument for createObjectOffsetList cannot contain null.');\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    createStructOffsetList(list, startFunc) {\r\n        startFunc(this, list.length);\r\n        this.createObjectOffsetList(list);\r\n        return this.endVector();\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": []
}
