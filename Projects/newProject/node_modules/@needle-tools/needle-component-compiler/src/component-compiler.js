"use strict";
exports.__esModule = true;
exports.run = void 0;
var fs_1 = require("fs");
var ts = require("typescript");
var fs = require("fs");
var path = require("path");
var types = require("./types");
var dict = types.dict;
// add either of these two comments above a class to enforce code gen or disable it for the next class
var exportNextClassCommand = "@generate-component";
var dontExportNextClassCommand = "@dont-generate-component";
// add above field to add [SerializeField] attribute
var serializeCommand = "@serializeField";
// https://regex101.com/r/ltpcKT/2
var typePattern = new RegExp("@type ?(?<type>.+)");
var ifdefPattern = new RegExp("@ifdef ?(?<ifdef>.+)");
var CODEGEN_MARKER_START = "// NEEDLE_CODEGEN_START";
var CODEGEN_MARKER_END = "// NEEDLE_CODEGEN_END";
// will be set to true when e.g. a comment for export is found
var exportNextClass = false;
var dontExportNextClass = false;
var serializeField = false;
function resetExportNextClass() {
    dontExportNextClass = false;
    exportNextClass = false;
}
var typesFileContent = undefined;
function tryGetKnownType(str) {
    if (typesFileContent === undefined) {
        typesFileContent = null;
        var filePath = path.dirname(__dirname) + "/src/types.json";
        if (fs.existsSync(filePath)) {
            console.log("Reading types file");
            var content = fs.readFileSync(filePath, "utf8");
            typesFileContent = JSON.parse(content);
        }
    }
    if (typesFileContent) {
        var fullType = typesFileContent[str];
        if (fullType)
            console.log(fullType);
        return fullType;
    }
    return null;
}
// https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API
// const exportDir = "../dist";
var commentStarts = [];
var ExportContext = /** @class */ (function () {
    function ExportContext(outputDir, fileName) {
        this.classEnd = -1;
        this.indentLevel = 0;
        this.emitMethodContextMenu = null;
        this.outputDir = outputDir;
        this.fileName = fileName;
        this.reset();
    }
    ExportContext.prototype.onBeforeMethod = function (name) {
        if (this.emitMethodContextMenu !== undefined) {
            var contextMenuText = this.emitMethodContextMenu === null ? name : this.emitMethodContextMenu;
            this.appendLine("[UnityEngine.ContextMenu(\"" + contextMenuText + "\")]");
        }
    };
    ExportContext.prototype.append = function (text) {
        for (var i = 0; i < this.indentLevel; i++)
            text = "\t" + text;
        this.textBuffer += text;
        this.emitMethodContextMenu = undefined;
    };
    ExportContext.prototype.appendLine = function (text) {
        this.append(text + "\n");
    };
    ExportContext.prototype.flush = function () {
        if (this.textBuffer.length <= 0)
            return;
        var dir = this.outputDir + "/";
        var path = dir + this.fileName;
        this.replaceGeneratedCodeSection(path);
        console.log("Write to " + path);
        fs.writeFileSync(path, this.textBuffer);
        this.reset();
    };
    ExportContext.prototype.reset = function () {
        this.textBuffer = "";
        this.classEnd = -1;
    };
    ExportContext.prototype.replaceGeneratedCodeSection = function (path) {
        this.textBuffer = CODEGEN_MARKER_START + "\n" + this.textBuffer + "\n" + CODEGEN_MARKER_END;
        if (fs.existsSync(path)) {
            var existing = fs.readFileSync(path, "utf8");
            var regex = new RegExp("(?<before>.*?)\/\/ ?NEEDLE_CODEGEN_START.+\/\/ ?NEEDLE_CODEGEN_END(?<after>.*)", "s");
            var matches = regex.exec(existing);
            if (matches === null || matches === void 0 ? void 0 : matches.groups) {
                console.log("Found codegen sections");
                var before = matches.groups.before;
                var after = matches.groups.after;
                this.textBuffer = before + this.textBuffer + after;
            }
        }
    };
    return ExportContext;
}());
var contexts = [];
var lastTypeFound = null;
var ifdefSections = [];
function run(program, outputDir, sourceFile) {
    if (!fs.existsSync(outputDir)) {
        console.error("Output directory does not exist: \"" + outputDir + "\"");
        return;
    }
    traverseFile(sourceFile);
    function traverseFile(node) {
        visit(node);
        ts.forEachChild(node, traverseFile);
    }
    function visit(node) {
        var _a, _b, _c, _d, _e, _f;
        var context = contexts.length > 0 ? contexts[contexts.length - 1] : null;
        if (context) {
            if ((context === null || context === void 0 ? void 0 : context.classEnd) > 0 && node.pos >= (context === null || context === void 0 ? void 0 : context.classEnd)) {
                while (context.indentLevel > 0) {
                    context.indentLevel -= 1;
                    context.append("}\n");
                }
                context.flush();
                context = null;
                contexts.pop();
            }
        }
        console.log("\t", ts.SyntaxKind[node.kind]);
        var commentRanges = ts.getLeadingCommentRanges(sourceFile.getFullText(), node.getFullStart());
        if (commentRanges === null || commentRanges === void 0 ? void 0 : commentRanges.length) {
            for (var _i = 0, commentRanges_1 = commentRanges; _i < commentRanges_1.length; _i++) {
                var r = commentRanges_1[_i];
                // avoid emitting comments multiple times
                if (commentStarts.includes(r.pos))
                    continue;
                commentStarts.push(r.pos);
                var comment = node.getSourceFile().getFullText().slice(r.pos, r.end);
                if (context) {
                    // https://regex101.com/r/ud4oev/1
                    var emitContextMenu = comment.match("(\/{2,}|\/\*)\s*@contextmenu {0,}(?<text>[a-zA-Z 0-9]+)?");
                    if (emitContextMenu) {
                        context.emitMethodContextMenu = (_b = (_a = emitContextMenu.groups) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : null;
                    }
                    else if (comment.includes(serializeCommand))
                        serializeField = true;
                }
                if (comment.includes(exportNextClassCommand))
                    exportNextClass = true;
                if (comment.includes(dontExportNextClassCommand))
                    dontExportNextClass = true;
                var typeMatch = typePattern.exec(comment);
                if (typeMatch && typeMatch.groups) {
                    // for some reason our regex does also match surrounding ( ) even tho: https://regex101.com/r/PoWK6V/1
                    // so we remove them
                    var type = typeMatch.groups["type"];
                    type = type.replace(/\(/, "").replace(/\)/, "");
                    console.log("Found type: ", type);
                    lastTypeFound = type;
                }
                var ifdefMatch = ifdefPattern.exec(comment);
                if (ifdefMatch && ifdefMatch.groups) {
                    var ifdef = ifdefMatch.groups["ifdef"];
                    if (ifdef)
                        ifdefSections.push(ifdef);
                }
            }
        }
        switch (node.kind) {
            // Namespace
            // case ts.SyntaxKind.ModuleDeclaration:
            //     const mod = node as ts.ModuleDeclaration;
            //     console.log(ts.SyntaxKind[mod.getChildAt(1).kind])
            //     const type = mod.getChildAt(1) as ts.Identifier;
            //     console.log("MODULE", type.text)
            //     break;
            // case ts.SyntaxKind.Identifier:
            //     break;
            // case ts.SyntaxKind.ClassDeclaration:
            // case ts.SyntaxKind.SingleLineCommentTrivia:
            //     console.log("comment: " + node.getText())
            //     break;
            case ts.SyntaxKind.Decorator:
                break;
            case ts.SyntaxKind.MethodDeclaration:
                lastTypeFound = null;
                serializeField = false;
                resetExportNextClass();
                if (!context)
                    break;
                // TODO: always emit at least OnEnable method per class so generated components have toggle in editor
                var meth = node;
                // const isCoroutine = func.asteriskToken;
                if (meth.name) {
                    var paramsStr = "";
                    for (var _g = 0, _h = meth.parameters; _g < _h.length; _g++) {
                        var param = _h[_g];
                        if (!param || !param.name)
                            continue;
                        if (paramsStr.length > 0)
                            paramsStr += ", ";
                        var type = tryResolveTypeRecursive(param);
                        if (type === undefined)
                            type = "object";
                        paramsStr += type + " @" + param.name.getText();
                    }
                    var methodName = meth.name.getText();
                    context.onBeforeMethod(methodName);
                    context.append("public void " + methodName + "(" + paramsStr + "){}\n");
                }
                break;
            case ts.SyntaxKind.SetAccessor:
            case ts.SyntaxKind.PropertyDeclaration:
                resetExportNextClass();
                if (!context)
                    break;
                console.log("Found variable", node.getText());
                var vardec = node;
                var varName = "@" + vardec.name.getText();
                var pub = isPublic(vardec);
                var visibility = pub ? "public" : "private";
                var isAccessible = pub;
                if (!pub && serializeField) {
                    console.log("[SerializeField]");
                    context.appendLine("[UnityEngine.SerializeField]");
                    isAccessible = true;
                }
                if (!isAccessible) {
                    console.log("Skip because not public or serializeable");
                    break;
                }
                var name_1 = vardec.name.getText();
                console.log("Variable:", name_1);
                if (name_1.startsWith("\"@") || name_1.startsWith("\"$") || name_1.startsWith("$"))
                    break;
                var typeString = lastTypeFound !== null && lastTypeFound !== void 0 ? lastTypeFound : tryResolveTypeRecursive(node);
                var postFix = "";
                var typeName = (_c = vardec.type) === null || _c === void 0 ? void 0 : _c.getText();
                if (typeString === undefined) {
                    postFix = " → Could not resolve C# type";
                }
                var prefix = typeString === undefined ? "// " : "";
                var assignment = "";
                if (typeString !== undefined) {
                    for (var _j = 0, _k = node.getChildren(); _j < _k.length; _j++) {
                        var ch = _k[_j];
                        switch (ch.kind) {
                            default:
                                // console.log("Unknown assignment:", ts.SyntaxKind[ch.kind]);
                                break;
                            case ts.SyntaxKind.NewExpression:
                                assignment = " = " + getTypeForAssignment(ch);
                                break;
                            case ts.SyntaxKind.FalseKeyword:
                            case ts.SyntaxKind.TrueKeyword:
                                assignment = " = " + ch.getText();
                                break;
                            case ts.SyntaxKind.StringLiteral:
                                var str = ch;
                                assignment = " = \"" + str.text + "\"";
                                break;
                            case ts.SyntaxKind.FirstLiteralToken:
                                var lit = ch;
                                assignment = " = " + lit.text;
                                if (ts.isNumericLiteral(lit))
                                    assignment += "f";
                                break;
                            case ts.SyntaxKind.ArrayLiteralExpression:
                                var arr = ch;
                                assignment = " = new " + typeString;
                                // if (arr.elements.length > 0) {
                                assignment += "{" + arr.elements.map(function (e) { return " " + getTypeForAssignment(e); }) + " }";
                                // }
                                break;
                        }
                    }
                }
                var requireEndIf = false;
                if (ifdefSections.length > 0) {
                    requireEndIf = true;
                    context.appendLine("#ifdef " + ifdefSections.pop());
                }
                if (typeString === undefined)
                    typeString = typeName;
                console.log("EMIT member: " + typeString + " " + varName);
                context.append(prefix + visibility + " " + typeString + " " + varName + assignment + ";" + postFix + "\n");
                lastTypeFound = null;
                if (requireEndIf) {
                    context.appendLine("#endif");
                }
                break;
            case ts.SyntaxKind.ClassDeclaration:
                serializeField = false;
                var dec = node;
                // a class must inherit a component
                var inheritsComponent = testInheritsComponent(node);
                if (!dontExportNextClass && (lastTypeFound || exportNextClass || inheritsComponent)) {
                    resetExportNextClass();
                    var name_2 = (_d = dec.name) === null || _d === void 0 ? void 0 : _d.escapedText;
                    console.log("Found class: ", name_2);
                    var namespace = (_e = tryParseNamespace(node)) !== null && _e !== void 0 ? _e : "Needle.Typescript.GeneratedComponents";
                    console.log("NAMESPACE", namespace);
                    var newContext = new ExportContext(outputDir, name_2 + ".cs");
                    newContext.appendLine("// auto generated code - do not edit directly");
                    newContext.appendLine("");
                    newContext.appendLine("#pragma warning disable");
                    newContext.appendLine("");
                    newContext.appendLine("namespace " + namespace);
                    newContext.appendLine("{");
                    newContext.indentLevel += 1;
                    // newContext.appendLine("// source: " + path.resolve(sourceFile.fileName));
                    var typeName_1 = "UnityEngine.MonoBehaviour";
                    if (typeof inheritsComponent === "string")
                        typeName_1 = inheritsComponent;
                    if (lastTypeFound)
                        typeName_1 = lastTypeFound;
                    console.log(name_2 + " inherits " + typeName_1);
                    newContext.appendLine("public partial class " + name_2 + " : " + typeName_1);
                    newContext.appendLine("{");
                    newContext.indentLevel += 1;
                    newContext.classEnd = dec.end;
                    contexts.push(newContext);
                }
                else {
                    console.log("Class type is unknown and will not generate a component: ", (_f = dec.name) === null || _f === void 0 ? void 0 : _f.escapedText);
                }
                lastTypeFound = null;
                break;
        }
        function testInheritsComponent(node) {
            switch (node.kind) {
                case ts.SyntaxKind.ClassDeclaration:
                    var dec = node;
                    if (dec.heritageClauses) {
                        for (var _i = 0, _a = dec.heritageClauses; _i < _a.length; _i++) {
                            var h = _a[_i];
                            if (h.types.length <= 0)
                                continue;
                            for (var _b = 0, _c = h.types; _b < _c.length; _b++) {
                                var type = _c[_b];
                                // const symbol = program.getTypeChecker().getSymbolAtLocation(type.expression);
                                // console.log(symbol);
                                var text = type.expression.getText();
                                if (text === "Component")
                                    return true;
                                if (text === "Behaviour")
                                    return true;
                                var known = tryGetKnownType(text);
                                if (known)
                                    return known;
                            }
                        }
                    }
                    return false;
            }
            return false;
        }
        function getTypeForAssignment(node) {
            // console.log("-------------------\nAssign", ts.SyntaxKind[node.kind]);
            switch (node.kind) {
                case ts.SyntaxKind.FirstLiteralToken:
                    return node.getText();
                case ts.SyntaxKind.NewExpression:
                    var type = undefined;
                    var args = undefined;
                    for (var _i = 0, _a = node.getChildren(); _i < _a.length; _i++) {
                        var ch = _a[_i];
                        var text = ch.getText();
                        // console.log("child", ts.SyntaxKind[ch.kind], text);
                        switch (ch.kind) {
                            case ts.SyntaxKind.Identifier:
                            case ts.SyntaxKind.PropertyAccessExpression:
                                type = tryGetTypeFromText(text);
                                break;
                            case ts.SyntaxKind.SyntaxList:
                                args = text;
                                break;
                        }
                    }
                    if (!args)
                        args = "";
                    if (type)
                        return "new " + type + "(" + args + ")";
                    // const expType = node.getChildren().find(c => c.kind === ts.SyntaxKind.Identifier);
                    break;
            }
            var str = node.getText();
            console.log("Unknown assignment:", str, ts.SyntaxKind[node.kind]);
            return str;
        }
        function isPublic(node) {
            if (node.kind === ts.SyntaxKind.PublicKeyword) {
                return true;
            }
            else if (node.kind === ts.SyntaxKind.PrivateKeyword) {
                return false;
            }
            for (var _i = 0, _a = node.getChildren(); _i < _a.length; _i++) {
                var ch = _a[_i];
                if (!isPublic(ch))
                    return false;
            }
            return true;
        }
        function tryParseNamespace(node, namespace) {
            // console.log("TRAVERSE - " + ts.SyntaxKind[node.kind]);
            switch (node.kind) {
                case ts.SyntaxKind.ModuleDeclaration:
                    for (var _i = 0, _a = node.getChildren(); _i < _a.length; _i++) {
                        var ch = _a[_i];
                        // console.log("-- TRAVERSE - " + ts.SyntaxKind[ch.kind]);
                        switch (ch.kind) {
                            case ts.SyntaxKind.Identifier:
                                var id = ch;
                                if (id.text) {
                                    if (!namespace)
                                        namespace = "";
                                    namespace = id.text + (namespace ? "." : "") + namespace;
                                }
                                break;
                        }
                    }
                    break;
            }
            if (node.parent) {
                return tryParseNamespace(node.parent, namespace);
            }
            return namespace;
        }
        function tryGetTypeFromText(typeName) {
            var res = dict[typeName];
            if (res === undefined) {
                switch (typeName) {
                    case "Array":
                        break;
                    default:
                        var knownType = tryGetKnownType(typeName);
                        res = knownType !== null && knownType !== void 0 ? knownType : undefined;
                        break;
                }
            }
            return res;
        }
        function tryResolveTypeRecursive(node) {
            if (!node)
                return undefined;
            // skip decorators (e.g. @serializable() may break array generation)
            if (node.kind === ts.SyntaxKind.Decorator)
                return undefined;
            var typeName = node === null || node === void 0 ? void 0 : node.getText();
            var varDec = node;
            if (varDec.type) {
                typeName = varDec.type.getText();
            }
            var res = undefined;
            // console.log("Unknown type: " + typeName);
            switch (node.kind) {
                // case ts.SyntaxKind.SyntaxList:
                //     const list = node as ts.SyntaxList;
                //     for (const ch of list._children) {
                //         res = tryResolveTypeRecursive(ch);
                //     }
                //     break;
                case ts.SyntaxKind.UnionType:
                    var union = node;
                    for (var _i = 0, _a = union.types; _i < _a.length; _i++) {
                        var t = _a[_i];
                        res = tryResolveTypeRecursive(t);
                        if (res !== undefined)
                            return res;
                    }
                    break;
                case ts.SyntaxKind.ArrayType:
                    res = "[]";
                    break;
                case ts.SyntaxKind.TypeReference:
                    var typeRef = node;
                    var typeName_2 = typeRef.typeName.getText();
                    console.log("TypeReference:", typeName_2);
                    switch (typeName_2) {
                        case "Array":
                            break;
                        default:
                            return tryGetTypeFromText(typeName_2);
                    }
                    // return res;
                    break;
                case ts.SyntaxKind.BooleanKeyword:
                case ts.SyntaxKind.NumberKeyword:
                case ts.SyntaxKind.StringKeyword:
                case ts.SyntaxKind.ObjectKeyword:
                    var keyword = node.getText();
                    // the basic keywords are declared in the static dictionary
                    // no need for a complex lookup
                    res = dict[keyword];
                    break;
                case ts.SyntaxKind.Identifier:
                    var id = node;
                    switch (id.text) {
                        // if we have an array we dont want to use the System.Array as a type but just make it to the array syntax
                        case "Array":
                            res = "[]";
                            break;
                        default:
                            // console.log(id.text);
                            // res = tryGetTypeFromText(id.text);
                            break;
                    }
                    break;
            }
            var isInGenericDeclaration = false;
            for (var _b = 0, _c = node.getChildren(); _b < _c.length; _b++) {
                var child = _c[_b];
                // if (res !== undefined) break;
                // console.log("Child type: " + ts.SyntaxKind[child.kind]);
                var isGenericStart = false;
                var isAssignment = false;
                switch (child.kind) {
                    case ts.SyntaxKind.FirstAssignment:
                        isAssignment = true;
                        break;
                    case ts.SyntaxKind.FirstBinaryOperator:
                        // console.log("Generic start: " + child.getText());
                        isInGenericDeclaration = true;
                        isGenericStart = true;
                        break;
                    case ts.SyntaxKind.GreaterThanGreaterThanToken:
                        isInGenericDeclaration = false;
                        // console.log("Generic end: " + child.getText());
                        break;
                }
                // if (isAssignment) break;
                var childResult = tryResolveTypeRecursive(child);
                if (childResult !== undefined) {
                    if (res === undefined)
                        res = "";
                    console.log("Child: " + ts.SyntaxKind[child.kind] + " → " + childResult);
                    // if the thing is a generic return as generic result
                    if (isInGenericDeclaration && !res.includes("[]")) {
                        res = "<" + childResult + ">";
                    }
                    // we got a generic result, these need to be appended
                    else if (childResult.startsWith("<")) {
                        res += childResult;
                    }
                    // concat default
                    else
                        res = childResult + res;
                }
            }
            // if (ts.isTypeReferenceNode(node)) {
            //     const typeRef = node as ts.TypeReferenceNode;
            //     const typeName = typeRef.typeName.getText();
            //     switch (typeName) {
            //         case "Array":
            //             res += "[]";
            //             return res;
            //     }
            // }
            return res;
        }
    }
}
exports.run = run;
if (process.argv.length < 4) {
    console.error("Missing args, call with: <output_dir> <input_files>");
}
else {
    var outputDir_1 = process.argv[2];
    var fileNames = process.argv.slice(3);
    fileNames.forEach(function (fileName) {
        // Parse a file
        var sourceFile = ts.createSourceFile(fileName, (0, fs_1.readFileSync)(fileName).toString(), ts.ScriptTarget.ES2015, 
        /*setParentNodes */ true);
        var prog = ts.createProgram([fileName], {});
        // delint it
        run(prog, outputDir_1, sourceFile);
    });
}
