import { readFileSync } from "fs";
import * as ts from "typescript";
import * as fs from "fs";
import * as path from 'path';

import * as types from "./types";
const dict = types.dict;

// add either of these two comments above a class to enforce code gen or disable it for the next class
const exportNextClassCommand = "@generate-component";
const dontExportNextClassCommand = "@dont-generate-component";
// add above field to add [SerializeField] attribute
const serializeCommand = "@serializeField";
// https://regex101.com/r/ltpcKT/2
const typePattern = new RegExp("@type ?(?<type>.+)");
const ifdefPattern = new RegExp("@ifdef ?(?<ifdef>.+)")

const CODEGEN_MARKER_START = "// NEEDLE_CODEGEN_START";
const CODEGEN_MARKER_END = "// NEEDLE_CODEGEN_END";

// will be set to true when e.g. a comment for export is found
let exportNextClass: boolean = false;
let dontExportNextClass: boolean = false;
let serializeField: boolean = false;
function resetExportNextClass() {
    dontExportNextClass = false;
    exportNextClass = false;
}


let typesFileContent: object | undefined | null = undefined;
function tryGetKnownType(str: string): string | null {
    if (typesFileContent === undefined) {
        typesFileContent = null;
        const filePath = path.dirname(__dirname) + "/src/types.json";
        if (fs.existsSync(filePath)) {
            console.log("Reading types file");
            const content = fs.readFileSync(filePath, "utf8");
            typesFileContent = JSON.parse(content);
        }
    }

    if (typesFileContent) {
        const fullType = typesFileContent[str];
        if (fullType)
            console.log(fullType);
        return fullType;
    }
    return null;
}

// https://github.com/microsoft/TypeScript/wiki/Using-the-Compiler-API

// const exportDir = "../dist";
const commentStarts: Array<number> = [];

class ExportContext {
    outputDir: string;
    fileName: string;
    textBuffer: string;
    classEnd: number = -1;
    indentLevel: number = 0;

    constructor(outputDir: string, fileName: string) {
        this.outputDir = outputDir;
        this.fileName = fileName;
        this.reset();
    }

    emitMethodContextMenu: string | null | undefined = null;

    onBeforeMethod(name: string) {
        if (this.emitMethodContextMenu !== undefined) {
            const contextMenuText = this.emitMethodContextMenu === null ? name : this.emitMethodContextMenu;
            this.appendLine("[UnityEngine.ContextMenu(\"" + contextMenuText + "\")]");
        }
    }

    append(text: string) {
        for (let i = 0; i < this.indentLevel; i++)
            text = "\t" + text;
        this.textBuffer += text;
        this.emitMethodContextMenu = undefined;
    }

    appendLine(text: string) {
        this.append(text + "\n");
    }

    flush() {
        if (this.textBuffer.length <= 0) return;
        const dir = this.outputDir + "/";
        const path = dir + this.fileName;
        this.replaceGeneratedCodeSection(path);
        console.log("Write to " + path);
        fs.writeFileSync(path, this.textBuffer);
        this.reset();
    }

    reset() {
        this.textBuffer = "";
        this.classEnd = -1;
    }

    private replaceGeneratedCodeSection(path: string) {
        this.textBuffer = CODEGEN_MARKER_START + "\n" + this.textBuffer + "\n" + CODEGEN_MARKER_END;
        if (fs.existsSync(path)) {
            const existing = fs.readFileSync(path, "utf8");
            const regex = new RegExp("(?<before>.*?)\/\/ ?NEEDLE_CODEGEN_START.+\/\/ ?NEEDLE_CODEGEN_END(?<after>.*)", "s");
            const matches = regex.exec(existing);
            if (matches?.groups) {
                console.log("Found codegen sections")
                const before = matches.groups.before;
                const after = matches.groups.after;
                this.textBuffer = before + this.textBuffer + after;
            }
        }
    }
}

const contexts: ExportContext[] = [];

let lastTypeFound: string | null = null;
let ifdefSections: string[] = [];

export function run(program: ts.Program, outputDir: string, sourceFile: ts.SourceFile) {

    if (!fs.existsSync(outputDir)) {
        console.error("Output directory does not exist: \"" + outputDir + "\"");
        return;
    }

    traverseFile(sourceFile);
    function traverseFile(node: ts.Node) {

        visit(node);
        ts.forEachChild(node, traverseFile);
    }

    function visit(node: ts.Node) {
        let context: ExportContext | null = contexts.length > 0 ? contexts[contexts.length - 1] : null;

        if (context) {
            if (context?.classEnd > 0 && node.pos >= context?.classEnd) {
                while (context.indentLevel > 0) {
                    context.indentLevel -= 1;
                    context.append("}\n");
                }
                context.flush();
                context = null;
                contexts.pop();
            }
        }
        console.log("\t", ts.SyntaxKind[node.kind]);

        const commentRanges = ts.getLeadingCommentRanges(
            sourceFile.getFullText(),
            node.getFullStart());
        if (commentRanges?.length) {
            for (const r of commentRanges) {
                // avoid emitting comments multiple times
                if (commentStarts.includes(r.pos)) continue;
                commentStarts.push(r.pos);
                const comment = node.getSourceFile().getFullText().slice(r.pos, r.end);
                if (context) {
                    // https://regex101.com/r/ud4oev/1
                    const emitContextMenu = comment.match("(\/{2,}|\/\*)\s*@contextmenu {0,}(?<text>[a-zA-Z 0-9]+)?");
                    if (emitContextMenu) {
                        context.emitMethodContextMenu = emitContextMenu.groups?.text ?? null;
                    }
                    else if (comment.includes(serializeCommand))
                        serializeField = true;
                }
                if (comment.includes(exportNextClassCommand))
                    exportNextClass = true;
                if (comment.includes(dontExportNextClassCommand))
                    dontExportNextClass = true;
                const typeMatch = typePattern.exec(comment);
                if (typeMatch && typeMatch.groups) {
                    // for some reason our regex does also match surrounding ( ) even tho: https://regex101.com/r/PoWK6V/1
                    // so we remove them
                    let type = typeMatch.groups["type"];
                    type = type.replace(/\(/, "").replace(/\)/, "");
                    console.log("Found type: ", type);
                    lastTypeFound = type;
                }

                const ifdefMatch = ifdefPattern.exec(comment);
                if (ifdefMatch && ifdefMatch.groups) {
                    const ifdef = ifdefMatch.groups["ifdef"];
                    if (ifdef)
                        ifdefSections.push(ifdef);
                }
            }
        }

        switch (node.kind) {
            // Namespace
            // case ts.SyntaxKind.ModuleDeclaration:
            //     const mod = node as ts.ModuleDeclaration;
            //     console.log(ts.SyntaxKind[mod.getChildAt(1).kind])
            //     const type = mod.getChildAt(1) as ts.Identifier;
            //     console.log("MODULE", type.text)
            //     break;
            // case ts.SyntaxKind.Identifier:
            //     break;
            // case ts.SyntaxKind.ClassDeclaration:
            // case ts.SyntaxKind.SingleLineCommentTrivia:
            //     console.log("comment: " + node.getText())
            //     break;
            case ts.SyntaxKind.Decorator:
                break;
            case ts.SyntaxKind.MethodDeclaration:
                lastTypeFound = null;
                serializeField = false;
                resetExportNextClass();
                if (!context) break;
                // TODO: always emit at least OnEnable method per class so generated components have toggle in editor
                const meth = node as ts.MethodDeclaration;
                // const isCoroutine = func.asteriskToken;
                if (meth.name) {
                    let paramsStr = "";
                    for (let param of meth.parameters) {
                        if (!param || !param.name) continue;
                        if (paramsStr.length > 0) paramsStr += ", ";
                        let type = tryResolveTypeRecursive(param);
                        if (type === undefined) type = "object";
                        paramsStr += type + " @" + param.name.getText();
                    }
                    const methodName = meth.name.getText();
                    context.onBeforeMethod(methodName);
                    context.append("public void " + methodName + "(" + paramsStr + "){}\n");
                }
                break;


            case ts.SyntaxKind.SetAccessor:
            case ts.SyntaxKind.PropertyDeclaration:
                resetExportNextClass();
                if (!context) break;
                console.log("Found variable", node.getText());
                const vardec = node as ts.VariableDeclaration;

                const varName = "@" + vardec.name.getText();
                const pub = isPublic(vardec);
                const visibility = pub ? "public" : "private";
                let isAccessible = pub;
                if (!pub && serializeField) {
                    console.log("[SerializeField]");
                    context.appendLine("[UnityEngine.SerializeField]");
                    isAccessible = true;
                }
                if (!isAccessible) {
                    console.log("Skip because not public or serializeable")
                    break;
                }

                const name = vardec.name.getText();
                console.log("Variable:", name);
                if (name.startsWith("\"@") || name.startsWith("\"$") || name.startsWith("$")) break;
                let typeString = lastTypeFound ?? tryResolveTypeRecursive(node);
                let postFix = "";
                let typeName = vardec.type?.getText();
                if (typeString === undefined) {
                    postFix = " → Could not resolve C# type";
                }
                const prefix = typeString === undefined ? "// " : "";
                let assignment = "";
                if (typeString !== undefined) {
                    for (const ch of node.getChildren()) {
                        switch (ch.kind) {
                            default:
                                // console.log("Unknown assignment:", ts.SyntaxKind[ch.kind]);
                                break;
                            case ts.SyntaxKind.NewExpression:
                                assignment = " = " + getTypeForAssignment(ch);
                                break;
                            case ts.SyntaxKind.FalseKeyword:
                            case ts.SyntaxKind.TrueKeyword:
                                assignment = " = " + ch.getText();
                                break;
                            case ts.SyntaxKind.StringLiteral:
                                const str = ch as ts.StringLiteral;
                                assignment = " = \"" + str.text + "\"";
                                break;
                            case ts.SyntaxKind.FirstLiteralToken:
                                const lit = ch as ts.LiteralExpression;
                                assignment = " = " + lit.text;
                                if (ts.isNumericLiteral(lit))
                                    assignment += "f";
                                break;
                            case ts.SyntaxKind.ArrayLiteralExpression:
                                const arr = ch as ts.ArrayLiteralExpression;
                                assignment = " = new " + typeString;
                                // if (arr.elements.length > 0) {
                                assignment += "{" + arr.elements.map(e => " " + getTypeForAssignment(e)) + " }";
                                // }
                                break;
                        }
                    }
                }
                let requireEndIf = false;
                if (ifdefSections.length > 0) {
                    requireEndIf = true;
                    context.appendLine("#ifdef " + ifdefSections.pop());
                }
                if (typeString === undefined) typeString = typeName;
                console.log("EMIT member: " + typeString + " " + varName)
                context.append(prefix + visibility + " " + typeString + " " + varName + assignment + ";" + postFix + "\n");
                lastTypeFound = null;
                if (requireEndIf) {
                    context.appendLine("#endif");
                }
                break;

            case ts.SyntaxKind.ClassDeclaration:
                serializeField = false;
                const dec = <ts.ClassDeclaration>node;
                // a class must inherit a component
                const inheritsComponent = testInheritsComponent(node);
                if (!dontExportNextClass && (lastTypeFound || exportNextClass || inheritsComponent)) {
                    resetExportNextClass();
                    const name = dec.name?.escapedText;
                    console.log("Found class: ", name);
                    const namespace = tryParseNamespace(node) ?? "Needle.Typescript.GeneratedComponents";
                    console.log("NAMESPACE", namespace);
                    const newContext = new ExportContext(outputDir, name + ".cs");
                    newContext.appendLine("// auto generated code - do not edit directly");
                    newContext.appendLine("");
                    newContext.appendLine("#pragma warning disable");
                    newContext.appendLine("");
                    newContext.appendLine("namespace " + namespace);
                    newContext.appendLine("{");
                    newContext.indentLevel += 1;
                    // newContext.appendLine("// source: " + path.resolve(sourceFile.fileName));
                    let typeName = "UnityEngine.MonoBehaviour";
                    if (typeof inheritsComponent === "string") typeName = inheritsComponent;
                    if (lastTypeFound) typeName = lastTypeFound;
                    console.log(name + " inherits " + typeName);
                    newContext.appendLine("public partial class " + name + " : " + typeName);
                    newContext.appendLine("{");
                    newContext.indentLevel += 1;
                    newContext.classEnd = dec.end;
                    contexts.push(newContext);
                }
                else {
                    console.log("Class type is unknown and will not generate a component: ", dec.name?.escapedText);
                }
                lastTypeFound = null;
                break;
        }

        function testInheritsComponent(node: ts.Node): boolean | string {
            switch (node.kind) {
                case ts.SyntaxKind.ClassDeclaration:
                    const dec = <ts.ClassDeclaration>node;
                    if (dec.heritageClauses) {
                        for (const h of dec.heritageClauses) {
                            if (h.types.length <= 0) continue;
                            for (const type of h.types) {
                                // const symbol = program.getTypeChecker().getSymbolAtLocation(type.expression);
                                // console.log(symbol);
                                const text = type.expression.getText();
                                if (text === "Component") return true;
                                if (text === "Behaviour") return true;
                                const known = tryGetKnownType(text);
                                if (known) return known;
                            }
                        }
                    }
                    return false;
            }
            return false;
        }

        function getTypeForAssignment(node: ts.Node) {
            // console.log("-------------------\nAssign", ts.SyntaxKind[node.kind]);
            switch (node.kind) {
                case ts.SyntaxKind.FirstLiteralToken:
                    return node.getText();
                case ts.SyntaxKind.NewExpression:
                    let type: string | undefined = undefined;
                    let args: string | undefined = undefined;
                    for (const ch of node.getChildren()) {
                        const text = ch.getText();
                        // console.log("child", ts.SyntaxKind[ch.kind], text);
                        switch (ch.kind) {
                            case ts.SyntaxKind.Identifier:
                            case ts.SyntaxKind.PropertyAccessExpression:
                                type = tryGetTypeFromText(text);
                                break;
                            case ts.SyntaxKind.SyntaxList:
                                args = text;
                                break;
                        }
                    }
                    if (!args) args = "";
                    if (type)
                        return "new " + type + "(" + args + ")";
                    // const expType = node.getChildren().find(c => c.kind === ts.SyntaxKind.Identifier);
                    break;
            }
            const str = node.getText();
            console.log("Unknown assignment:", str, ts.SyntaxKind[node.kind]);
            return str;
        }

        function isPublic(node: ts.Node): boolean {
            if (node.kind === ts.SyntaxKind.PublicKeyword) {
                return true;
            }
            else if (node.kind === ts.SyntaxKind.PrivateKeyword) {
                return false;
            }

            for (const ch of node.getChildren()) {
                if (!isPublic(ch)) return false;
            }
            return true;
        }

        function tryParseNamespace(node: ts.Node, namespace?: string): string | null | undefined {
            // console.log("TRAVERSE - " + ts.SyntaxKind[node.kind]);
            switch (node.kind) {
                case ts.SyntaxKind.ModuleDeclaration:
                    for (const ch of node.getChildren()) {
                        // console.log("-- TRAVERSE - " + ts.SyntaxKind[ch.kind]);
                        switch (ch.kind) {
                            case ts.SyntaxKind.Identifier:
                                const id = ch as ts.Identifier;
                                if (id.text) {
                                    if (!namespace) namespace = "";
                                    namespace = id.text + (namespace ? "." : "") + namespace;
                                }
                                break;
                        }
                    }
                    break;
            }
            if (node.parent) {
                return tryParseNamespace(node.parent, namespace);
            }
            return namespace;
        }

        function tryGetTypeFromText(typeName: string) {
            let res = dict[typeName];
            if (res === undefined) {
                switch (typeName) {
                    case "Array":
                        break;
                    default:
                        const knownType = tryGetKnownType(typeName);
                        res = knownType ?? undefined;
                        break;
                }
            }
            return res;
        }

        function tryResolveTypeRecursive(node: ts.Node | ts.VariableDeclaration): string | undefined {
            if (!node) return undefined;

            // skip decorators (e.g. @serializable() may break array generation)
            if (node.kind === ts.SyntaxKind.Decorator)
                return undefined;

            let typeName = node?.getText();

            const varDec: ts.VariableDeclaration = node as ts.VariableDeclaration;
            if (varDec.type) {
                typeName = varDec.type.getText();
            }

            let res: string | undefined = undefined;



            // console.log("Unknown type: " + typeName);

            switch (node.kind) {
                // case ts.SyntaxKind.SyntaxList:
                //     const list = node as ts.SyntaxList;
                //     for (const ch of list._children) {
                //         res = tryResolveTypeRecursive(ch);
                //     }
                //     break;
                case ts.SyntaxKind.UnionType:
                    const union = node as ts.UnionTypeNode;
                    for (const t of union.types) {
                        res = tryResolveTypeRecursive(t);
                        if (res !== undefined) return res;
                    }
                    break;

                case ts.SyntaxKind.ArrayType:
                    res = "[]";
                    break;

                case ts.SyntaxKind.TypeReference:
                    const typeRef = node as ts.TypeReferenceNode;
                    const typeName = typeRef.typeName.getText();
                    console.log("TypeReference:", typeName);
                    switch (typeName) {
                        case "Array":
                            break;
                        default:
                            return tryGetTypeFromText(typeName);
                    }
                    // return res;
                    break;

                case ts.SyntaxKind.BooleanKeyword:
                case ts.SyntaxKind.NumberKeyword:
                case ts.SyntaxKind.StringKeyword:
                case ts.SyntaxKind.ObjectKeyword:
                    const keyword = node.getText();
                    // the basic keywords are declared in the static dictionary
                    // no need for a complex lookup
                    res = dict[keyword];
                    break;

                case ts.SyntaxKind.Identifier:
                    const id = node as ts.Identifier;
                    switch (id.text) {
                        // if we have an array we dont want to use the System.Array as a type but just make it to the array syntax
                        case "Array":
                            res = "[]";
                            break;
                        default:
                            // console.log(id.text);
                            // res = tryGetTypeFromText(id.text);
                            break;
                    }
                    break;
            }

            let isInGenericDeclaration = false;
            for (const child of node.getChildren()) {
                // if (res !== undefined) break;
                // console.log("Child type: " + ts.SyntaxKind[child.kind]);
                let isGenericStart = false;
                let isAssignment = false;
                switch (child.kind) {
                    case ts.SyntaxKind.FirstAssignment:
                        isAssignment = true;
                        break;
                    case ts.SyntaxKind.FirstBinaryOperator:
                        // console.log("Generic start: " + child.getText());
                        isInGenericDeclaration = true;
                        isGenericStart = true;
                        break;
                    case ts.SyntaxKind.GreaterThanGreaterThanToken:
                        isInGenericDeclaration = false;
                        // console.log("Generic end: " + child.getText());
                        break;
                }
                // if (isAssignment) break;
                const childResult = tryResolveTypeRecursive(child);
                if (childResult !== undefined) {
                    if (res === undefined) res = "";
                    console.log("Child: " + ts.SyntaxKind[child.kind] + " → " + childResult);
                    // if the thing is a generic return as generic result
                    if (isInGenericDeclaration && !res.includes("[]")) {
                        res = "<" + childResult + ">";
                    }
                    // we got a generic result, these need to be appended
                    else if (childResult.startsWith("<")) {
                        res += childResult;
                    }
                    // concat default
                    else
                        res = childResult + res;
                }
            }

            // if (ts.isTypeReferenceNode(node)) {
            //     const typeRef = node as ts.TypeReferenceNode;
            //     const typeName = typeRef.typeName.getText();
            //     switch (typeName) {
            //         case "Array":
            //             res += "[]";
            //             return res;
            //     }
            // }

            return res;
        }
    }
}

if (process.argv.length < 4) {
    console.error("Missing args, call with: <output_dir> <input_files>");
}
else {
    const outputDir = process.argv[2];
    const fileNames = process.argv.slice(3);
    fileNames.forEach(fileName => {
        // Parse a file
        const sourceFile = ts.createSourceFile(
            fileName,
            readFileSync(fileName).toString(),
            ts.ScriptTarget.ES2015,
        /*setParentNodes */ true
        );

        const prog = ts.createProgram([fileName], {});

        // delint it
        run(prog, outputDir, sourceFile);
    });
}