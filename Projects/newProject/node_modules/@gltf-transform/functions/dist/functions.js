var e=require("@gltf-transform/core"),t=require("ndarray-pixels"),r=require("@gltf-transform/extensions"),n=require("gl-matrix/mat4"),o=require("gl-matrix/vec3"),s=require("ndarray"),i=require("ndarray-lanczos");function a(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var c=/*#__PURE__*/a(s);const u=function(e,r,n){try{if(!e)return Promise.resolve(null);const o=e.getImage();return o?Promise.resolve(t.getPixels(o,e.getMimeType())).then(function(e){for(let t=0;t<e.shape[0];++t)for(let r=0;r<e.shape[1];++r)n(e,t,r);return Promise.resolve(t.savePixels(e,"image/png")).then(function(e){return r.setImage(e).setMimeType("image/png")})}):Promise.resolve(null)}catch(e){return Promise.reject(e)}};function l(e,t){return Object.defineProperty(t,"name",{value:e}),t}function g(e,t,r){return!!e&&e.stack.lastIndexOf(t)<e.stack.lastIndexOf(r)}class f{constructor(){this._map=new Map}get size(){return this._map.size}has(e){return this._map.has(e)}add(e,t){let r=this._map.get(e);return r||(r=new Set,this._map.set(e,r)),r.add(t),this}get(e){return this._map.get(e)||new Set}keys(){return this._map.keys()}}function p(e,t=2){if(0===e)return"0 Bytes";const r=t<0?0:t,n=Math.floor(Math.log(e)/Math.log(1e3));return parseFloat((e/Math.pow(1e3,n)).toFixed(r))+" "+["Bytes","KB","MB","GB","TB","PB","EB","ZB","YB"][n]}function m(e){return e.toString().replace(/\B(?=(\d{3})+(?!\d))/g,",")}function d(e,t){return`${m(e)} → ${m(t)} (${function(e,t,r=2){return(e>t?"–":"+")+(Math.abs(e-t)/e*100).toFixed(r)+"%"}(e,t)})`}function h(e){const t=[];for(const r of e.listAttributes())t.push(r);for(const r of e.listTargets())for(const e of r.listAttributes())t.push(e);return Array.from(new Set(t))}function y(e,t,r){e.swap(t,r);for(const n of e.listTargets())n.swap(t,r)}function T(e,t,r){const n=e.getElementSize(),o=e.getCount(),s=e.getArray(),i=s.slice(0,r*n);for(let e=0;e<o;e++)for(let r=0;r<n;r++)i[t[e]*n+r]=s[e*n+r];e.setArray(i)}function A(e,t=e){const r=t<=65534?new Uint16Array(e):new Uint32Array(e);for(let e=0;e<r.length;e++)r[e]=e;return r}const E={pivot:"center"},S="colorspace",P={propertyTypes:[e.PropertyType.ACCESSOR,e.PropertyType.MESH,e.PropertyType.TEXTURE,e.PropertyType.MATERIAL]},b=function(t=P){const r={...P,...t},n=new Set(r.propertyTypes);for(const e of r.propertyTypes)if(!P.propertyTypes.includes(e))throw new Error(`dedup: Unsupported deduplication on type "${e}".`);return l("dedup",t=>{const r=t.getLogger();n.has(e.PropertyType.ACCESSOR)&&function(t,r){const n=new Set,o=new Set,s=new Set,i=new Set,a=r.getRoot().listMeshes();a.forEach(e=>{e.listPrimitives().forEach(e=>{e.listAttributes().forEach(e=>o.add(e));const t=e.getIndices();t&&n.add(t)})});for(const e of r.getRoot().listAnimations())for(const t of e.listSamplers()){const e=t.getInput(),r=t.getOutput();e&&s.add(e),r&&i.add(r)}function c(t){const r=new Map;for(let n=0;n<t.length;n++){const o=t[n],s=e.BufferUtils.toView(o.getArray());if(!r.has(o))for(let n=0;n<t.length;n++){const i=t[n];o!==i&&(r.has(i)||o.getType()===i.getType()&&o.getComponentType()===i.getComponentType()&&o.getCount()===i.getCount()&&o.getNormalized()===i.getNormalized()&&e.BufferUtils.equals(s,e.BufferUtils.toView(i.getArray()))&&r.set(i,o))}}return r}const u=c(Array.from(n));t.debug(`dedup: Found ${u.size} duplicates among ${n.size} indices.`);const l=c(Array.from(o));t.debug(`dedup: Found ${l.size} duplicates among ${o.size} attributes.`);const g=c(Array.from(s)),f=c(Array.from(i));t.debug(`dedup: Found ${g.size+f.size} duplicates among ${s.size+i.size} animation accessors.`),a.forEach(e=>{e.listPrimitives().forEach(e=>{e.listAttributes().forEach(t=>{l.has(t)&&e.swap(t,l.get(t))});const t=e.getIndices();t&&u.has(t)&&e.swap(t,u.get(t))})}),Array.from(u.keys()).forEach(e=>e.dispose()),Array.from(l.keys()).forEach(e=>e.dispose());for(const e of r.getRoot().listAnimations())for(const t of e.listSamplers()){const e=t.getInput(),r=t.getOutput();e&&g.has(e)&&t.swap(e,g.get(e)),r&&f.has(r)&&t.swap(r,f.get(r))}Array.from(g.keys()).forEach(e=>e.dispose()),Array.from(f.keys()).forEach(e=>e.dispose())}(r,t),n.has(e.PropertyType.MESH)&&function(t,r){const n=r.getRoot(),o=new Map;n.listAccessors().forEach((e,t)=>o.set(e,t)),n.listMaterials().forEach((e,t)=>o.set(e,t));const s=n.listMeshes().length,i=new Map;for(const t of n.listMeshes()){const r=[];for(const e of t.listPrimitives())r.push(I(e,o));const n=r.join(";");if(i.has(n)){const r=i.get(n);t.listParents().forEach(n=>{n.propertyType!==e.PropertyType.ROOT&&n.swap(t,r)}),t.dispose()}else i.set(n,t)}t.debug(`dedup: Found ${s-i.size} duplicates among ${s} meshes.`)}(r,t),n.has(e.PropertyType.TEXTURE)&&function(t,r){const n=r.getRoot(),o=n.listTextures(),s=new Map;for(let t=0;t<o.length;t++){const r=o[t],n=r.getImage();if(!s.has(r))for(let t=0;t<o.length;t++){const i=o[t],a=i.getImage();if(r===i)continue;if(s.has(i))continue;if(r.getMimeType()!==i.getMimeType())continue;const c=r.getSize(),u=i.getSize();c&&u&&c[0]===u[0]&&c[1]===u[1]&&n&&a&&e.BufferUtils.equals(n,a)&&s.set(i,r)}}t.debug(`dedup: Found ${s.size} duplicates among ${n.listTextures().length} textures.`),Array.from(s.entries()).forEach(([t,r])=>{t.listParents().forEach(n=>{n instanceof e.Root||n.swap(t,r)}),t.dispose()})}(r,t),n.has(e.PropertyType.MATERIAL)&&function(t,r){const n=r.getRoot(),o=n.listMaterials(),s=new Map,i=new Set(["name"]);for(let e=0;e<o.length;e++){const t=o[e];if(!s.has(t))for(let e=0;e<o.length;e++){const r=o[e];t!==r&&(s.has(r)||t.equals(r,i)&&s.set(r,t))}}t.debug(`dedup: Found ${s.size} duplicates among ${n.listMaterials().length} materials.`),Array.from(s.entries()).forEach(([t,r])=>{t.listParents().forEach(n=>{n instanceof e.Root||n.swap(t,r)}),t.dispose()})}(r,t),r.debug("dedup: Complete.")})};function I(t,r){const n=[];for(const e of t.listSemantics()){const o=t.getAttribute(e);n.push(e+":"+r.get(o))}if(t instanceof e.Primitive){const e=t.getIndices();e&&n.push("indices:"+r.get(e));const o=t.getMaterial();o&&n.push("material:"+r.get(o)),n.push("mode:"+t.getMode());for(const e of t.listTargets())n.push("target:"+I(e,r))}return n.join(",")}const M={pattern:/^((?!JOINTS_).)*$/};function R(e,t){for(const r of e.listSemantics())w(r,e.getAttribute(r),t);for(const r of e.listTargets())for(const e of r.listSemantics())w(e,r.getAttribute(e),t)}function w(e,t,r){if(!t.getArray())return;if(!r.pattern.test(e))return;if(t.getComponentSize()>=4)return;const n=t.getArray(),o=new Float32Array(n.length);for(let e=0,r=t.getCount(),s=[];e<r;e++)s=t.getElement(e,s),t.setArray(o).setElement(e,s).setArray(n);t.setArray(o).setNormalized(!1)}const x={method:"edgebreaker",encodeSpeed:5,decodeSpeed:5,quantizePosition:14,quantizeNormal:10,quantizeColor:8,quantizeTexcoord:12,quantizeGeneric:12,quantizationVolume:"mesh"};function C(t){return{properties:t.getRoot().listScenes().map(t=>{const r=t.listChildren()[0],n=e.bounds(t);return{name:t.getName(),rootName:r?r.getName():"",bboxMin:q(n.min),bboxMax:q(n.max)}})}}function v(t){return{properties:t.getRoot().listMeshes().map(t=>{const r=t.listParents().filter(t=>t.propertyType!==e.PropertyType.ROOT).length;let n=0,o=0;const s=new Set,i=new Set,a=new Set;t.listPrimitives().forEach(t=>{for(const e of t.listSemantics()){const r=t.getAttribute(e);s.add(e+":"+_(r)),a.add(r)}for(const e of t.listTargets())e.listAttributes().forEach(e=>a.add(e));const r=t.getIndices();r&&(i.add(_(r)),a.add(r)),o+=t.listAttributes()[0].getCount(),n+=function(t){const r=t.getIndices(),n=t.getAttribute("POSITION");switch(t.getMode()){case e.Primitive.Mode.POINTS:return n.getCount();case e.Primitive.Mode.LINES:return r?r.getCount()/2:n.getCount()/2;case e.Primitive.Mode.LINE_LOOP:return n.getCount();case e.Primitive.Mode.LINE_STRIP:return n.getCount()-1;case e.Primitive.Mode.TRIANGLES:return r?r.getCount()/3:n.getCount()/3;case e.Primitive.Mode.TRIANGLE_STRIP:case e.Primitive.Mode.TRIANGLE_FAN:return n.getCount()-2;default:throw new Error("Unexpected mode: "+t.getMode())}}(t)});let c=0;Array.from(a).forEach(e=>c+=e.getArray().byteLength);const u=t.listPrimitives().map(e=>$[e.getMode()]);return{name:t.getName(),mode:Array.from(new Set(u)),primitives:t.listPrimitives().length,glPrimitives:n,vertices:o,indices:Array.from(i).sort(),attributes:Array.from(s).sort(),instances:r,size:c}})}}function N(t){return{properties:t.getRoot().listMaterials().map(r=>{const n=r.listParents().filter(t=>t.propertyType!==e.PropertyType.ROOT).length,o=new Set(r.listExtensions()),s=t.getGraph().listEdges().filter(t=>{const n=t.getChild(),s=t.getParent();return n instanceof e.Texture&&s===r||!!(n instanceof e.Texture&&s instanceof e.ExtensionProperty&&o.has(s))}).map(e=>e.getName());return{name:r.getName(),instances:n,textures:s,alphaMode:r.getAlphaMode(),doubleSided:r.getDoubleSided()}})}}function O(t){return{properties:t.getRoot().listTextures().map(r=>{const n=r.listParents().filter(t=>t.propertyType!==e.PropertyType.ROOT).length,o=t.getGraph().listParentEdges(r).filter(t=>t.getParent().propertyType!==e.PropertyType.ROOT).map(e=>e.getName()),s=e.ImageUtils.getSize(r.getImage(),r.getMimeType());return{name:r.getName(),uri:r.getURI(),slots:Array.from(new Set(o)),instances:n,mimeType:r.getMimeType(),resolution:s?s.join("x"):"",size:r.getImage().byteLength,gpuSize:e.ImageUtils.getMemSize(r.getImage(),r.getMimeType())}})}}function z(e){return{properties:e.getRoot().listAnimations().map(e=>{let t=Infinity,r=-Infinity;e.listSamplers().forEach(e=>{const n=e.getInput();n&&(t=Math.min(t,n.getMin([])[0]),r=Math.max(r,n.getMax([])[0]))});let n=0,o=0;const s=new Set;return e.listSamplers().forEach(e=>{const t=e.getInput(),r=e.getOutput();t&&(o+=t.getCount(),s.add(t),r&&s.add(r))}),Array.from(s).forEach(e=>{n+=e.getArray().byteLength}),{name:e.getName(),channels:e.listChannels().length,samplers:e.listSamplers().length,duration:Math.round(1e3*(r-t))/1e3,keyframes:o,size:n}})}}const $=["POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN"],L={Float32Array:"f32",Uint32Array:"u32",Uint16Array:"u16",Uint8Array:"u8",Int32Array:"i32",Int16Array:"i16",Int8Array:"i8"};function q(e){for(let t=0;t<e.length;t++)e[t].toFixed&&(e[t]=Number(e[t].toFixed(5)));return e}function _(e){const t=e.getArray();return(L[t.constructor.name]||"?")+(e.getNormalized()?"_norm":"")}const U={};function F(t,r){let n,o=0;for(;n=t.pop();){if(n.listChildren().length||n.getCamera()||n.getMesh()||n.getSkin()||n.listExtensions().length)continue;const r=n.getParent();r instanceof e.Node&&t.push(r),n.dispose(),o++}r.debug(`instance: Removed ${o} unused nodes.`)}function k(e,t,r,n){const o=r.listPrimitives()[0].getAttribute("POSITION").getBuffer(),s=e.createAccessor().setType("VEC3").setArray(new Float32Array(3*n)).setBuffer(o),i=e.createAccessor().setType("VEC4").setArray(new Float32Array(4*n)).setBuffer(o),a=e.createAccessor().setType("VEC3").setArray(new Float32Array(3*n)).setBuffer(o);return t.createInstancedMesh().setAttribute("TRANSLATION",s).setAttribute("ROTATION",i).setAttribute("SCALE",a)}const B={propertyTypes:[e.PropertyType.NODE,e.PropertyType.SKIN,e.PropertyType.MESH,e.PropertyType.CAMERA,e.PropertyType.PRIMITIVE,e.PropertyType.PRIMITIVE_TARGET,e.PropertyType.ANIMATION,e.PropertyType.MATERIAL,e.PropertyType.TEXTURE,e.PropertyType.ACCESSOR,e.PropertyType.BUFFER],keepLeaves:!1},G=function(t=B){const r={...B,...t},n=r.propertyTypes;return l("prune",t=>{const o=t.getLogger(),s=t.getRoot(),i=t.getGraph(),a={};if(r.keepLeaves||s.listScenes().forEach(function t(r){if(r.listChildren().forEach(t),r instanceof e.Scene)return;const n=i.listParentEdges(r).some(e=>"targetNode"===e.getName());0!==i.listChildren(r).length||n||(r.dispose(),l(r))}),n.includes(e.PropertyType.NODE)&&s.listNodes().forEach(c),n.includes(e.PropertyType.SKIN)&&s.listSkins().forEach(c),n.includes(e.PropertyType.MESH)&&s.listMeshes().forEach(c),n.includes(e.PropertyType.CAMERA)&&s.listCameras().forEach(c),n.includes(e.PropertyType.PRIMITIVE)&&u(i,e.PropertyType.PRIMITIVE),n.includes(e.PropertyType.PRIMITIVE_TARGET)&&u(i,e.PropertyType.PRIMITIVE_TARGET),n.includes(e.PropertyType.ANIMATION))for(const e of s.listAnimations()){for(const t of e.listChannels())t.getTargetNode()||(t.dispose(),l(t));if(e.listChannels().length)e.listSamplers().forEach(c);else{const t=e.listSamplers();c(e),t.forEach(c)}}if(n.includes(e.PropertyType.MATERIAL)&&s.listMaterials().forEach(c),n.includes(e.PropertyType.TEXTURE)&&s.listTextures().forEach(c),n.includes(e.PropertyType.ACCESSOR)&&s.listAccessors().forEach(c),n.includes(e.PropertyType.BUFFER)&&s.listBuffers().forEach(c),Object.keys(a).length){const e=Object.keys(a).map(e=>`${e} (${a[e]})`).join(", ");o.info(`prune: Removed types... ${e}`)}else o.info("prune: No unused properties found.");function c(t){t.listParents().filter(t=>!(t instanceof e.Root||t instanceof e.AnimationChannel)).length||(t.dispose(),l(t))}function u(e,t){e.listEdges().map(e=>e.getParent()).filter(e=>e.propertyType===t).forEach(c)}function l(e){a[e.propertyType]=a[e.propertyType]||0,a[e.propertyType]++}o.debug("prune: Complete.")})},j={target:"size"};function D(t){const r={...j,...t},n=r.encoder;if(!n)throw new Error('reorder: encoder dependency required — install "meshoptimizer".');return l("reorder",function(t){try{const o=t.getLogger();return Promise.resolve(n.ready).then(function(){const s=W(t);for(const t of s.indicesToAttributes.keys()){const o=t.clone();let i=o.getArray().slice();i instanceof Uint32Array||(i=new Uint32Array(i));const[a,c]=n.reorderMesh(i,s.indicesToMode.get(t)===e.Primitive.Mode.TRIANGLES,"size"===r.target);o.setArray(c<=65534?new Uint16Array(i):i);for(const e of s.indicesToAttributes.get(t)){const r=e.clone();T(r,a,c);for(const n of s.attributesToPrimitives.get(e))if(n.getIndices()===t&&n.swap(t,o),n.getIndices()===o){n.swap(e,r);for(const t of n.listTargets())t.swap(e,r)}}}return Promise.resolve(t.transform(G({propertyTypes:[e.PropertyType.ACCESSOR]}))).then(function(){s.indicesToAttributes.size?o.debug("reorder: Complete."):o.warn("reorder: No qualifying primitives found; may need to weld first.")})})}catch(e){return Promise.reject(e)}})}function W(e){const t=new f,r=new Map,n=new f;for(const o of e.getRoot().listMeshes())for(const e of o.listPrimitives()){const o=e.getIndices();if(o){r.set(o,e.getMode());for(const r of h(e))t.add(o,r),n.add(r,e)}}return{indicesToAttributes:t,indicesToMode:r,attributesToPrimitives:n}}const V=[Int8Array,Int16Array,Int32Array],{TRANSLATION:H,ROTATION:X,SCALE:K,WEIGHTS:Z}=e.AnimationChannel.TargetPath,J=[H,X,K],Q={pattern:/.*/,quantizationVolume:"mesh",quantizePosition:14,quantizeNormal:10,quantizeTexcoord:12,quantizeColor:8,quantizeWeight:8,quantizeGeneric:12,normalizeWeights:!0},Y=(t=Q)=>{const n={...Q,...t};return l("quantize",function(t){try{const s=t.getLogger(),i=t.getRoot();let a;t.createExtension(r.MeshQuantization).setRequired(!0),"scene"===n.quantizationVolume&&(a=te(function(e){const t=e[0];for(const r of e)o.min(t.min,t.min,r.min),o.max(t.max,t.max,r.max);return t}(i.listMeshes().map(ae))));for(const e of t.getRoot().listMeshes()){"mesh"===n.quantizationVolume&&(a=te(ae(e))),a&&n.pattern.test("POSITION")&&(re(t,e,a),oe(e,1/a.scale));for(const r of e.listPrimitives()){ee(t,r,a,n);for(const e of r.listTargets())ee(t,e,a,n)}}return Promise.resolve(t.transform(G({propertyTypes:[e.PropertyType.ACCESSOR,e.PropertyType.SKIN,e.PropertyType.MATERIAL]}),b({propertyTypes:[e.PropertyType.ACCESSOR,e.PropertyType.MATERIAL]}))).then(function(){s.debug("quantize: Complete.")})}catch(e){return Promise.reject(e)}})};function ee(t,r,s,i){const a=t.getLogger();for(const t of r.listSemantics()){if(!i.pattern.test(t))continue;const c=r.getAttribute(t),{bits:u,ctor:l}=ie(t,c,a,i);if(!l)continue;if(u<8||u>16)throw new Error("quantize: Requires bits = 8–16.");if(c.getComponentSize()<=u/8)continue;const g=c.clone();if("POSITION"===t){const t=s.scale,i=[];r instanceof e.Primitive?n.invert(i,ue(s)):n.fromScaling(i,[1/t,1/t,1/t]);for(let e=0,t=[0,0,0],r=g.getCount();e<r;e++)g.getElement(e,t),g.setElement(e,o.transformMat4(t,t,i))}se(g,l,u),r.swap(c,g)}if(i.normalizeWeights&&r.getAttribute("WEIGHTS_0")&&function(e){const t=e.getAttribute("POSITION").getCount(),r=[];for(let n=0;n<t;n++){let t,o=0,s=Infinity,i=-1,a=null,c=0;for(;t=e.getAttribute("WEIGHTS_"+c++);){t.getElement(n,r);for(let e=0;e<r.length;e++)o+=r[e],r[e]>0&&r[e]<s&&(a=t,s=r[e],i=e)}a&&1!==o&&(a.getElement(n,r),r[i]+=1-o,a.setElement(n,r))}}(r),r instanceof e.Primitive&&r.getIndices()&&r.listAttributes().length&&r.listAttributes()[0].getCount()<65535){const e=r.getIndices();e.setArray(new Uint16Array(e.getArray()))}}function te(e){const{min:t,max:r}=e,n=Math.max((r[0]-t[0])/2,(r[1]-t[1])/2,(r[2]-t[2])/2);return{offset:[t[0]+(r[0]-t[0])/2,t[1]+(r[1]-t[1])/2,t[2]+(r[2]-t[2])/2],scale:n}}function re(t,r,o){const s=ue(o);for(const i of r.listParents()){if(!(i instanceof e.Node))continue;const a=i.listParents().filter(t=>t instanceof e.AnimationChannel),c=a.some(e=>J.includes(e.getTargetPath())),u=i.listChildren().length>0;if(i.getSkin()){i.setSkin(ne(i.getSkin(),o));continue}let l;u||c?(l=t.createNode("").setMesh(r),i.addChild(l).setMesh(null),a.filter(e=>e.getTargetPath()===Z).forEach(e=>e.setTargetNode(l))):l=i;const g=l.getMatrix();n.multiply(g,g,s),l.setMatrix(g)}}function ne(e,t){e=e.clone();const r=ue(t),o=e.getInverseBindMatrices().clone(),s=[];for(let e=0,t=o.getCount();e<t;e++)o.getElement(e,s),n.multiply(s,s,r),o.setElement(e,s);return e.setInverseBindMatrices(o)}function oe(e,t){for(const r of e.listPrimitives()){let e=r.getMaterial();if(!e)continue;let n=e.getExtension("KHR_materials_volume");!n||n.getThicknessFactor()<=0||(n=n.clone().setThicknessFactor(n.getThicknessFactor()*t),e=e.clone().setExtension("KHR_materials_volume",n),r.setMaterial(e))}}function se(e,t,r){const n=new t(e.getArray().length),o=V.includes(t)?1:0,s=r-o,i=8*t.BYTES_PER_ELEMENT-o,a=Math.pow(2,s)-1,c=i-s,u=2*s-i;for(let t=0,r=0,o=[];t<e.getCount();t++){e.getElement(t,o);for(let e=0;e<o.length;e++){let t=Math.round(Math.abs(o[e])*a);t=t<<c|t>>u,n[r++]=t*Math.sign(o[e])}}e.setArray(n).setNormalized(!0)}function ie(e,t,r,n){const o=t.getMinNormalized([]),s=t.getMaxNormalized([]);let i,a;if("POSITION"===e)i=n.quantizePosition,a=i<=8?Int8Array:Int16Array;else if("NORMAL"===e||"TANGENT"===e)i=n.quantizeNormal,a=i<=8?Int8Array:Int16Array;else if(e.startsWith("COLOR_"))i=n.quantizeColor,a=i<=8?Uint8Array:Uint16Array;else if(e.startsWith("TEXCOORD_")){if(o.some(e=>e<0)||s.some(e=>e>1))return r.warn(`quantize: Skipping ${e}; out of [0,1] range.`),{bits:-1};i=n.quantizeTexcoord,a=i<=8?Uint8Array:Uint16Array}else{if(e.startsWith("JOINTS_"))return i=Math.max(...t.getMax([]))<=255?8:16,a=i<=8?Uint8Array:Uint16Array,t.getComponentSize()>i/8&&t.setArray(new a(t.getArray())),{bits:-1};if(e.startsWith("WEIGHTS_")){if(o.some(e=>e<0)||s.some(e=>e>1))return r.warn(`quantize: Skipping ${e}; out of [0,1] range.`),{bits:-1};i=n.quantizeWeight,a=i<=8?Uint8Array:Uint16Array}else{if(!e.startsWith("_"))throw new Error(`quantize: Unexpected semantic, "${e}".`);if(o.some(e=>e<-1)||s.some(e=>e>1))return r.warn(`quantize: Skipping ${e}; out of [-1,1] range.`),{bits:-1};i=n.quantizeGeneric,a=a=o.some(e=>e<0)?i<=8?Int8Array:Int16Array:i<=8?Uint8Array:Uint16Array}}return{bits:i,ctor:a}}function ae(e){const t=[],r=[];for(const n of e.listPrimitives()){const e=n.getAttribute("POSITION");e&&t.push(e);for(const e of n.listTargets()){const t=e.getAttribute("POSITION");t&&r.push(t)}}if(0===t.length)throw new Error('quantize: Missing "POSITION" attribute.');const n=ce(t,3);if(r.length>0){const{min:e,max:t}=ce(r,3);o.min(n.min,n.min,o.min(e,o.scale(e,e,2),[0,0,0])),o.max(n.max,n.max,o.max(t,o.scale(t,t,2),[0,0,0]))}return n}function ce(e,t){const r=new Array(t).fill(Infinity),n=new Array(t).fill(-Infinity),o=[],s=[];for(const i of e){i.getMinNormalized(o),i.getMaxNormalized(s);for(let e=0;e<t;e++)r[e]=Math.min(r[e],o[e]),n[e]=Math.max(n[e],s[e])}return{min:r,max:n}}function ue(e){return n.fromRotationTranslationScale([],[0,0,0,1],e.offset,[e.scale,e.scale,e.scale])}const le={level:"high"},ge=/*#__PURE__*/"undefined"!=typeof Symbol?Symbol.iterator||(Symbol.iterator=Symbol("Symbol.iterator")):"@@iterator";function fe(e,t,r){if(!e.s){if(r instanceof pe){if(!r.s)return void(r.o=fe.bind(null,e,t));1&t&&(t=r.s),r=r.v}if(r&&r.then)return void r.then(fe.bind(null,e,t),fe.bind(null,e,2));e.s=t,e.v=r;const n=e.o;n&&n(e)}}const pe=/*#__PURE__*/function(){function e(){}return e.prototype.then=function(t,r){const n=new e,o=this.s;if(o){const e=1&o?t:r;if(e){try{fe(n,1,e(this.v))}catch(e){fe(n,2,e)}return n}return this}return this.o=function(e){try{const o=e.v;1&e.s?fe(n,1,t?t(o):o):r?fe(n,1,r(o)):fe(n,2,o)}catch(e){fe(n,2,e)}},n},e}();function me(e){return e instanceof pe&&1&e.s}const de={},he={};function ye(e=he){return l("unweld",e=>{const t=e.getLogger(),r=new Map;for(const n of e.getRoot().listMeshes())for(const e of n.listPrimitives()){const n=e.getIndices();if(!n)continue;const o=e.getAttribute("POSITION").getCount();for(const o of e.listAttributes())e.swap(o,Te(o,n,t,r)),1===o.listParents().length&&o.dispose();for(const o of e.listTargets())for(const e of o.listAttributes())o.swap(e,Te(e,n,t,r)),1===e.listParents().length&&e.dispose();const s=e.getAttribute("POSITION").getCount();t.debug(`unweld: ${d(o,s)} vertices.`),e.setIndices(null),1===n.listParents().length&&n.dispose()}t.debug("unweld: Complete.")})}function Te(e,t,r,n){if(n.has(e)&&n.get(e).has(t))return r.debug(`unweld: Cache hit for reused attribute, "${e.getName()}".`),n.get(e).get(t);const o=e.clone(),s=e.getArray().constructor;o.setArray(new s(t.getCount()*e.getElementSize()));const i=[];for(let r=0;r<t.getCount();r++)o.setElement(r,e.getElement(t.getScalar(r),i));return n.has(e)||n.set(e,new Map),n.get(e).set(t,o),o}const Ae={overwrite:!1};function Ee(e,t,r){const n=[t[0]-e[0],t[1]-e[1],t[2]-e[2]],s=[r[0]-e[0],r[1]-e[1],r[2]-e[2]];return o.normalize([0,0,0],[n[1]*s[2]-n[2]*s[1],n[2]*s[0]-n[0]*s[2],n[0]*s[1]-n[1]*s[0]])}const Se={animations:!0,meshes:!0};function Pe(e,t){let r=`${e}.bin`,n=1;for(;t.has(r);)r=`${e}_${n++}.bin`;return r}const be={tolerance:1e-4};function Ie(e,t){const r=e.getInput().clone(),n=e.getOutput().clone(),o=t.tolerance,s=r.getCount()-1,i=[];let a=1;for(let t=1;t<s;++t){const s=r.getScalar(t),u=r.getScalar(t-1),l=r.getScalar(t+1),g=(s-u)/(l-u);let f=!1;if(s!==l&&(1!==t||s!==r.getScalar(0)))for(let r=0;r<n.getElementSize();r++){const s=n.getElement(t,i)[r],a=n.getElement(t-1,i)[r],u=n.getElement(t+1,i)[r];if("LINEAR"===e.getInterpolation()){if(Math.abs(s-(a*(1-(c=g))+u*c))>o){f=!0;break}}else if("STEP"===e.getInterpolation()&&(s!==a||s!==u)){f=!0;break}}f&&(t!==a&&(r.setScalar(a,r.getScalar(t)),n.setElement(a,n.getElement(t,i))),a++)}var c;s>0&&(r.setScalar(a,r.getScalar(s)),n.setElement(a,n.getElement(s,i)),a++),a!==r.getCount()?(r.setArray(r.getArray().slice(0,a)),n.setArray(n.getArray().slice(0,a*n.getElementSize())),e.setInput(r),e.setOutput(n)):(r.dispose(),n.dispose())}const Me={name:"",fps:10,pattern:/.*/,sort:!0},Re={tolerance:1e-4,overwrite:!0};function we(t=Re){const r={...Re,...t};if(r.tolerance>.1||r.tolerance<0)throw new Error("weld: Requires 0 ≤ tolerance ≤ 0.1");return l("weld",function(t,n){try{function o(){s.debug("weld: Complete.")}const s=t.getLogger();for(const n of t.getRoot().listMeshes())for(const o of n.listPrimitives()){if(o.getIndices()&&!r.overwrite)return Promise.resolve();if(o.getMode()===e.Primitive.Mode.POINTS)return Promise.resolve();0===r.tolerance?xe(t,o):Ce(t,o,r)}const i=function(){if(!g(n,"weld","dedup"))return Promise.resolve(t.transform(b({propertyTypes:[e.PropertyType.ACCESSOR]}))).then(function(){})}();return Promise.resolve(i&&i.then?i.then(o):o())}catch(e){return Promise.reject(e)}})}function xe(t,r){if(r.getIndices())return;const n=r.listAttributes()[0],o=n.getCount(),s=n.getBuffer(),i=o<=65534?new Uint16Array(o):new Uint32Array(o),a=t.createAccessor().setBuffer(s).setType(e.Accessor.Type.SCALAR).setArray(i);for(let e=0;e<a.getCount();e++)a.setScalar(e,e);r.setIndices(a)}function Ce(e,t,r){const n=e.getLogger(),o=t.getAttribute("POSITION"),s=t.getIndices()||e.createAccessor().setArray(A(o.getCount())),i=new Uint32Array(new Set(s.getArray())),a=Math.max(r.tolerance,Number.EPSILON),c={};for(const e of t.listSemantics()){const r=t.getAttribute(e);c[e]=ze(e,r,a)}var u;n.debug(`weld: Tolerance thresholds: ${u=c,Object.entries(u).map(([e,t])=>`${e}=${t}`).join(", ")}`);const l=[0,0,0],g=[0,0,0];i.sort((e,t)=>(o.getElement(e,l),o.getElement(t,g),l[0]>g[0]?1:-1));const f=A(i.length),p=A(i.length),m=o.getCount();let h=0,y=0;for(let e=0;e<i.length;e++){const r=i[e];for(let n=e-1;n>=0;n--){const e=f[i[n]];if(o.getElement(r,l),o.getElement(e,g),Math.abs(l[0]-g[0])>c.POSITION)break;y++;const s=t.listSemantics().every(n=>$e(t.getAttribute(n),r,e,c[n])),a=t.listTargets().every(n=>n.listSemantics().every(n=>$e(t.getAttribute(n),r,e,c[n])));if(s&&a){f[r]=e;break}}p[r]=f[r]===r?h++:p[f[r]]}n.debug(`weld: Iterations per vertex: ${Math.round(y/i.length)} (avg)`),n.debug(`weld: ${d(m,h)} vertices.`);const T=s.getCount(),E=A(T,i.length);for(let e=0;e<T;e++)E[e]=p[s.getScalar(e)];t.setIndices(s.clone().setArray(E)),1===s.listParents().length&&s.dispose();for(const e of t.listAttributes())ve(t,e,p,h);for(const e of t.listTargets())for(const t of e.listAttributes())ve(e,t,p,h)}function ve(e,t,r,n){const o=(s=t.getArray(),i=n*t.getElementSize(),new(0,s.constructor)(i));var s,i;const a=t.clone().setArray(o),c=new Uint8Array(n);for(let e=0,n=[];e<r.length;e++)c[r[e]]||(a.setElement(r[e],t.getElement(e,n)),c[r[e]]=1);e.swap(t,a),1===t.listParents().length&&t.dispose()}const Ne=[],Oe=[];function ze(e,t,r){return"NORMAL"===e||"TANGENT"===e?.5:e.startsWith("COLOR_")?.01:e.startsWith("TEXCOORD_")?1e-4:e.startsWith("JOINTS_")?0:e.startsWith("WEIGHTS_")?.01:(Ne.length=Oe.length=0,t.getMinNormalized(Ne),t.getMaxNormalized(Oe),r*(Math.max(...Oe)-Math.min(...Ne)||1))}function $e(e,t,r,n,o){e.getElement(t,Ne),e.getElement(r,Oe);for(let t=0,r=e.getElementSize();t<r;t++)if(Math.abs(Ne[t]-Oe[t])>n)return!1;return!0}const Le={ratio:.5,error:.001,lockBorder:!1};function qe(t,r,n){const o={...Le,...n},s=t.getLogger(),i=r.getAttribute("POSITION"),a=r.getIndices(),c=i.getCount();let u=i.getArray(),l=a.getArray();if(i.getComponentType()!==e.Accessor.ComponentType.FLOAT)if(i.getNormalized()){const e=u,t=new Float32Array(e.length);for(let r=0,n=i.getCount(),o=[];r<n;r++)o=i.getElement(r,o),i.setArray(t).setElement(r,o).setArray(e);u=t}else u=new Float32Array(u);a.getComponentType()!==e.Accessor.ComponentType.UNSIGNED_INT&&(l=new Uint32Array(l));const g=3*Math.floor(o.ratio*c/3),[f,p]=o.simplifier.simplify(l,u,3,g,o.error,o.lockBorder?["LockBorder"]:[]),[m,A]=o.simplifier.compactMesh(f);s.debug(`simplify: ${d(i.getCount(),A)} vertices, error: ${p.toFixed(4)}.`);for(const e of h(r)){const t=e.clone();T(t,m,A),y(r,e,t),1===e.listParents().length&&e.dispose()}const E=a.clone();return E.setArray(c<=65534?new Uint16Array(f):f),r.setIndices(E),1===a.listParents().length&&a.dispose(),r}function _e(t,r){let n=0;for(const o of t.getGraph().listParentEdges(r)){const r=o.getParent();let{channels:s}=o.getAttributes();s&&"baseColorTexture"===o.getName()&&r instanceof e.Material&&r.getAlphaMode()===e.Material.AlphaMode.OPAQUE&&(s&=~e.TextureChannel.A),s?n|=s:r.propertyType!==e.PropertyType.ROOT&&t.getLogger().warn(`Missing attribute ".channels" on edge, "${o.getName()}".`)}return n}function Ue(e,t){const r=e.getRoot(),n=e.getGraph().listParentEdges(t).filter(e=>e.getParent()!==r).map(e=>e.getName());return Array.from(new Set(n))}var Fe;!function(e){e.OXIPNG="oxipng",e.MOZJPEG="mozjpeg",e.WEBP="webp"}(Fe||(Fe={}));const ke={[Fe.OXIPNG]:"image/png",[Fe.MOZJPEG]:"image/jpeg",[Fe.WEBP]:"image/webp"},Be={jobs:4,formats:/.*/,slots:/.*/,auto:!1},Ge={...Be,codec:Fe.WEBP},je={...Be,codec:Fe.MOZJPEG,formats:/^image\/jpeg$/},De={...Be,codec:Fe.OXIPNG,formats:/^image\/png$/},We=["image/jpeg","image/png","image/webp"];let Ve=null,He=0;const Xe=(e,t)=>(Ve||(Ve=new e.ImagePool(t)),He++,Ve),Ke=()=>{He--,Ve&&He<=0&&(Ve.close(),Ve=null)},Ze=function(t){const r={...Be,...t},n=r.squoosh,o=r.codec;if(!n)throw new Error(`${o}: squoosh dependency required — install "@squoosh/lib".`);return function(t){try{const s=t.getLogger(),i=t.getRoot().listTextures(),a=Xe(n,r.jobs);return Promise.resolve(Promise.all(i.map(function(n,i){try{const c=Ue(t,n),u=_e(t,n),l=n.getURI()||n.getName()||`${i+1}/${t.getRoot().listTextures().length}`,g=`${o}:texture(${l})`;if(!We.includes(n.getMimeType()))return s.debug(`${g}: Skipping, unsupported texture type "${n.getMimeType()}".`),Promise.resolve();if(!r.formats.test(n.getMimeType()))return s.debug(`${g}: Skipping, "${n.getMimeType()}" excluded by "formats" parameter.`),Promise.resolve();if(c.length&&!c.some(e=>r.slots.test(e)))return s.debug(`${g}: Skipping, [${c.join(", ")}] excluded by "slots" parameter.`),Promise.resolve();if(r.codec===Fe.MOZJPEG&&u&e.TextureChannel.A)return s.warn(`${g}: Skipping, [${c.join(", ")}] requires alpha channel.`),Promise.resolve();s.debug(`${g}: Slots → [${c.join(", ")}]`);const f=a.ingestImage(n.getImage()),m=n.getImage().byteLength;return Promise.resolve(f.encode({[r.codec]:r.auto?"auto":{}})).then(function(){return Promise.resolve(f.encodedWith[r.codec]).then(function(e){s.debug(`${g}: ${JSON.stringify(e.optionsUsed)}`),n.setImage(e.binary).setMimeType(ke[r.codec]);const t=e.binary.byteLength;s.debug(`${g}: ${p(m)} → ${p(t)}`)})})}catch(e){return Promise.reject(e)}}))).then(function(){Ke(),s.debug(`${o}: Complete.`)})}catch(e){return Promise.reject(e)}}},Je={overwrite:!1};function Qe(e){const t=e.getMaterial();if(!t)return"TEXCOORD_0";const r=t.getNormalTextureInfo();if(!r)return"TEXCOORD_0";const n=`TEXCOORD_${r.getTexCoord()}`;return e.getAttribute(n)?n:"TEXCOORD_0"}function Ye(t,r,n,o,s){return t.getMode()===e.Primitive.Mode.TRIANGLES&&t.getAttribute("POSITION")&&t.getAttribute("NORMAL")&&t.getAttribute("TEXCOORD_0")?t.getAttribute("TANGENT")&&!s?(r.debug(`tangents: Skipping primitive ${o} of mesh "${n}": TANGENT found.`),!1):!t.getIndices()||(r.warn(`tangents: Skipping primitive ${o} of mesh "${n}": primitives must be unwelded.`),!1):(r.debug(`tangents: Skipping primitive ${o} of mesh "${n}": primitives must have attributes=[POSITION, NORMAL, TEXCOORD_0] and mode=TRIANGLES.`),!1)}const et=/*#__PURE__*/"undefined"!=typeof Symbol?Symbol.iterator||(Symbol.iterator=Symbol("Symbol.iterator")):"@@iterator";function tt(e,t,r){if(!e.s){if(r instanceof rt){if(!r.s)return void(r.o=tt.bind(null,e,t));1&t&&(t=r.s),r=r.v}if(r&&r.then)return void r.then(tt.bind(null,e,t),tt.bind(null,e,2));e.s=t,e.v=r;const n=e.o;n&&n(e)}}const rt=/*#__PURE__*/function(){function e(){}return e.prototype.then=function(t,r){const n=new e,o=this.s;if(o){const e=1&o?t:r;if(e){try{tt(n,1,e(this.v))}catch(e){tt(n,2,e)}return n}return this}return this.o=function(e){try{const o=e.v;1&e.s?tt(n,1,t?t(o):o):r?tt(n,1,r(o)):tt(n,2,o)}catch(e){tt(n,2,e)}},n},e}();function nt(e){return e instanceof rt&&1&e.s}const ot="textureResize";var st;(st=exports.TextureResizeFilter||(exports.TextureResizeFilter={})).LANCZOS3="lanczos3",st.LANCZOS2="lanczos2";const it={size:[2048,2048],filter:exports.TextureResizeFilter.LANCZOS3,pattern:null,slots:null},at={};Object.defineProperty(exports,"bounds",{enumerable:!0,get:function(){return e.bounds}}),exports.DRACO_DEFAULTS=x,exports.MESHOPT_DEFAULTS=le,exports.QUANTIZE_DEFAULTS=Q,exports.SIMPLIFY_DEFAULTS=Le,exports.TEXTURE_RESIZE_DEFAULTS=it,exports.WELD_DEFAULTS=Re,exports.center=function(t=E){const r={...E,...t};return l("center",t=>{const n=t.getLogger(),o=t.getRoot(),s=o.listAnimations().length>0||o.listSkins().length>0;t.getRoot().listScenes().forEach((i,a)=>{let c;if(n.debug(`center: Scene ${a+1} / ${o.listScenes().length}.`),"string"==typeof r.pivot){const t=e.bounds(i);c=[(t.max[0]-t.min[0])/2+t.min[0],(t.max[1]-t.min[1])/2+t.min[1],(t.max[2]-t.min[2])/2+t.min[2]],"above"===r.pivot&&(c[1]=t.max[1]),"below"===r.pivot&&(c[1]=t.min[1])}else c=r.pivot;n.debug(`center: Pivot "${c.join(", ")}".`);const u=[-1*c[0],-1*c[1],-1*c[2]];if(s){n.debug("center: Model contains animation or skin. Adding a wrapper node.");const e=t.createNode("Pivot").setTranslation(u);i.listChildren().forEach(t=>e.addChild(t)),i.addChild(e)}else n.debug("center: Skipping wrapper, offsetting all root nodes."),i.listChildren().forEach(e=>{const t=e.getTranslation();e.setTranslation([t[0]+u[0],t[1]+u[1],t[2]+u[2]])})}),n.debug("center: Complete.")})},exports.colorspace=function(e){return l(S,t=>{const r=t.getLogger();if("linear"===e.inputEncoding)return void r.info(`${S}: Vertex colors already linear. Skipping conversion.`);if("sRGB"!==e.inputEncoding)return void r.error(`${S}: Unknown input encoding "${e.inputEncoding}" – should be "sRGB" or "linear". Skipping conversion.`);const n=new Set;function o(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}function s(e){const t=[0,0,0];let r;for(let s=0;r=e.getAttribute(`COLOR_${s}`);s++)if(!n.has(r)){for(let e=0;e<r.getCount();e++)r.getElement(e,t),t[0]=o(t[0]),t[1]=o(t[1]),t[2]=o(t[2]),r.setElement(e,t);n.add(r)}}t.getRoot().listMeshes().forEach(e=>e.listPrimitives().forEach(s)),r.debug(`${S}: Complete.`)})},exports.createLayoutPlan=W,exports.dedup=b,exports.dequantize=function(e=M){const t={...M,...e};return l("dequantize",e=>{const n=e.getLogger();for(const r of e.getRoot().listMeshes())for(const e of r.listPrimitives())R(e,t);e.createExtension(r.MeshQuantization).dispose(),n.debug("dequantize: Complete.")})},exports.draco=e=>{const t={...x,...e};return e=>{e.createExtension(r.DracoMeshCompression).setRequired(!0).setEncoderOptions({method:"edgebreaker"===t.method?r.DracoMeshCompression.EncoderMethod.EDGEBREAKER:r.DracoMeshCompression.EncoderMethod.SEQUENTIAL,encodeSpeed:t.encodeSpeed,decodeSpeed:t.decodeSpeed,quantizationBits:{POSITION:t.quantizePosition,NORMAL:t.quantizeNormal,COLOR:t.quantizeColor,TEX_COORD:t.quantizeTexcoord,GENERIC:t.quantizeGeneric},quantizationVolume:t.quantizationVolume})}},exports.getTextureChannelMask=_e,exports.inspect=function(e){return{scenes:C(e),meshes:v(e),materials:N(e),textures:O(e),animations:z(e)}},exports.instance=function(t=U){return l("instance",t=>{const n=t.getLogger(),o=t.getRoot(),s=t.createExtension(r.MeshGPUInstancing);if(o.listAnimations().length)throw new Error("instance: Instancing is not currently supported for animated models.");let i=0,a=0;for(const r of o.listScenes()){const o=new Map;r.traverse(e=>{const t=e.getMesh();t&&o.set(t,(o.get(t)||new Set).add(e))});const c=[];for(const u of Array.from(o.keys())){const l=Array.from(o.get(u));if(l.length<2)continue;if(l.some(e=>e.getSkin()))continue;const g=k(t,s,u,l.length),f=g.getAttribute("TRANSLATION"),p=g.getAttribute("ROTATION"),m=g.getAttribute("SCALE"),d=t.createNode().setMesh(u).setExtension("EXT_mesh_gpu_instancing",g);r.addChild(d);let h=!1,y=!1,T=!1;for(let t=0;t<l.length;t++){let r,n,o;const s=l[t];f.setElement(t,r=s.getWorldTranslation()),p.setElement(t,n=s.getWorldRotation()),m.setElement(t,o=s.getWorldScale()),e.MathUtils.eq(r,[0,0,0])||(h=!0),e.MathUtils.eq(n,[0,0,0,1])||(y=!0),e.MathUtils.eq(o,[1,1,1])||(T=!0),s.setMesh(null),c.push(s)}h||f.dispose(),y||p.dispose(),T||m.dispose(),F(c,n),i++,a+=l.length}}i>0?n.info(`instance: Created ${i} batches, with ${a} total instances.`):(n.info("instance: No meshes with multiple parent nodes were found."),s.dispose()),n.debug("instance: Complete.")})},exports.listTextureChannels=function(t,r){const n=_e(t,r),o=[];return n&e.TextureChannel.R&&o.push(e.TextureChannel.R),n&e.TextureChannel.G&&o.push(e.TextureChannel.G),n&e.TextureChannel.B&&o.push(e.TextureChannel.B),n&e.TextureChannel.A&&o.push(e.TextureChannel.A),o},exports.listTextureSlots=Ue,exports.meshopt=e=>{const t={...le,...e},n=t.encoder;if(!n)throw new Error('meshopt: encoder dependency required — install "meshoptimizer".');return function(e){try{return Promise.resolve(e.transform(D({encoder:n,target:"size"}),Y({pattern:"medium"===t.level?/.*/:/^(POSITION|TEXCOORD|JOINTS|WEIGHTS)(_\d+)?$/,quantizePosition:14,quantizeTexcoord:12,quantizeColor:8,quantizeNormal:8}))).then(function(){e.createExtension(r.MeshoptCompression).setRequired(!0).setEncoderOptions({method:"medium"===t.level?r.MeshoptCompression.EncoderMethod.QUANTIZE:r.MeshoptCompression.EncoderMethod.FILTER})})}catch(e){return Promise.reject(e)}}},exports.metalRough=function(e=de){return l("metalRough",function(e){try{function t(){i.dispose();for(const e of a)e&&1===e.listParents().length&&e.dispose();n.debug("metalRough: Complete.")}const n=e.getLogger();if(!e.getRoot().listExtensionsUsed().map(e=>e.extensionName).includes("KHR_materials_pbrSpecularGlossiness"))return n.warn("metalRough: KHR_materials_pbrSpecularGlossiness not found on document."),Promise.resolve();const o=e.createExtension(r.MaterialsIOR),s=e.createExtension(r.MaterialsSpecular),i=e.createExtension(r.MaterialsPBRSpecularGlossiness),a=new Set,c=function(e,t,r){if("function"==typeof e[ge]){var n,o,s,i=e[ge]();if(function e(r){try{for(;!(n=i.next()).done;)if((r=t(n.value))&&r.then){if(!me(r))return void r.then(e,s||(s=fe.bind(null,o=new pe,2)));r=r.v}o?fe(o,1,r):o=r}catch(e){fe(o||(o=new pe),2,e)}}(),i.return){var a=function(e){try{n.done||i.return()}catch(e){}return e};if(o&&o.then)return o.then(a,function(e){throw a(e)});a()}return o}if(!("length"in e))throw new TypeError("Object is not iterable");for(var c=[],u=0;u<e.length;u++)c.push(e[u]);return function(e,t,r){var n,o,s=-1;return function r(i){try{for(;++s<e.length;)if((i=t(s))&&i.then){if(!me(i))return void i.then(r,o||(o=fe.bind(null,n=new pe,2)));i=i.v}n?fe(n,1,i):n=i}catch(e){fe(n||(n=new pe),2,e)}}(),n}(c,function(e){return t(c[e])})}(e.getRoot().listMaterials(),function(t){function r(){t.setExtension("KHR_materials_pbrSpecularGlossiness",null)}const n=t.getExtension("KHR_materials_pbrSpecularGlossiness");if(!n)return;const i=s.createSpecular().setSpecularFactor(1).setSpecularColorFactor(n.getSpecularFactor());a.add(n.getSpecularGlossinessTexture()),a.add(t.getBaseColorTexture()),a.add(t.getMetallicRoughnessTexture()),t.setBaseColorFactor(n.getDiffuseFactor()).setMetallicFactor(0).setRoughnessFactor(1).setExtension("KHR_materials_ior",o.createIOR().setIOR(1e3)).setExtension("KHR_materials_specular",i);const c=n.getDiffuseTexture();c&&(t.setBaseColorTexture(c),t.getBaseColorTextureInfo().copy(n.getDiffuseTextureInfo()));const l=n.getSpecularGlossinessTexture(),g=function(){if(l){const r=n.getSpecularGlossinessTextureInfo(),o=e.createTexture();return Promise.resolve(u(l,o,(e,t,r)=>{e.set(t,r,3,255)})).then(function(){i.setSpecularTexture(o),i.setSpecularColorTexture(o),i.getSpecularTextureInfo().copy(r),i.getSpecularColorTextureInfo().copy(r);const s=n.getGlossinessFactor(),a=e.createTexture();return Promise.resolve(u(l,a,(e,t,r)=>{const n=255-Math.round(e.get(t,r,3)*s);e.set(t,r,0,0),e.set(t,r,1,n),e.set(t,r,2,0),e.set(t,r,3,255)})).then(function(){t.setMetallicRoughnessTexture(a),t.getMetallicRoughnessTextureInfo().copy(r)})})}i.setSpecularColorFactor(n.getSpecularFactor()),t.setRoughnessFactor(1-n.getGlossinessFactor())}();return g&&g.then?g.then(r):r()});return Promise.resolve(c&&c.then?c.then(t):t())}catch(e){return Promise.reject(e)}})},exports.mozjpeg=function(e){const t={...je,...e};return e=>Ze(t)(e)},exports.normals=function(e=Ae){const t={...Ae,...e};return l("normals",function(e){try{const r=e.getLogger();let n=0;return Promise.resolve(e.transform(ye())).then(function(){for(const o of e.getRoot().listMeshes())for(const s of o.listPrimitives()){const o=s.getAttribute("POSITION");let i=s.getAttribute("NORMAL");if(t.overwrite&&i)i.dispose();else if(i)return void r.debug("normals: Skipping primitive: NORMAL found.");i=e.createAccessor().setArray(new Float32Array(3*o.getCount())).setType("VEC3");const a=[0,0,0],c=[0,0,0],u=[0,0,0];for(let e=0;e<o.getCount();e+=3){o.getElement(e+0,a),o.getElement(e+1,c),o.getElement(e+2,u);const t=Ee(a,c,u);i.setElement(e+0,t),i.setElement(e+1,t),i.setElement(e+2,t)}s.setAttribute("NORMAL",i),n++}n?r.debug("normals: Complete."):r.warn("normals: No qualifying primitives found. See debug output.")})}catch(e){return Promise.reject(e)}})},exports.oxipng=function(e){const t={...De,...e};return e=>Ze(t)(e)},exports.partition=(t=Se)=>{const r={...Se,...t};return l("partition",function(t){try{const n=t.getLogger();return!1!==r.meshes&&function(e,t,r){const n=new Set(e.getRoot().listBuffers().map(e=>e.getURI()));e.getRoot().listMeshes().forEach((o,s)=>{if(Array.isArray(r.meshes)&&!r.meshes.includes(o.getName()))return void t.debug(`partition: Skipping mesh #${s} with name "${o.getName()}".`);t.debug(`partition: Creating buffer for mesh "${o.getName()}".`);const i=e.createBuffer(o.getName()).setURI(Pe(o.getName()||"mesh",n));o.listPrimitives().forEach(e=>{const t=e.getIndices();t&&t.setBuffer(i),e.listAttributes().forEach(e=>e.setBuffer(i)),e.listTargets().forEach(e=>{e.listAttributes().forEach(e=>e.setBuffer(i))})})})}(t,n,r),!1!==r.animations&&function(e,t,r){const n=new Set(e.getRoot().listBuffers().map(e=>e.getURI()));e.getRoot().listAnimations().forEach((o,s)=>{if(Array.isArray(r.animations)&&!r.animations.includes(o.getName()))return void t.debug(`partition: Skipping animation #${s} with name "${o.getName()}".`);t.debug(`partition: Creating buffer for animation "${o.getName()}".`);const i=e.createBuffer(o.getName()).setURI(Pe(o.getName()||"animation",n));o.listSamplers().forEach(e=>{const t=e.getInput(),r=e.getOutput();t&&t.setBuffer(i),r&&r.setBuffer(i)})})}(t,n,r),r.meshes||r.animations||n.warn("partition: Select animations or meshes to create a partition."),Promise.resolve(t.transform(G({propertyTypes:[e.PropertyType.BUFFER]}))).then(function(){n.debug("partition: Complete.")})}catch(e){return Promise.reject(e)}})},exports.prune=G,exports.quantize=Y,exports.reorder=D,exports.resample=(t=be)=>{const r={...be,...t};return l("resample",(t,n)=>{const o=new Set,s=t.getRoot().listAccessors().length,i=t.getLogger();let a=!1;for(const e of t.getRoot().listAnimations()){const t=new Set;for(const r of e.listChannels())r.getSampler()&&"weights"===r.getTargetPath()&&t.add(r.getSampler());for(const n of e.listSamplers())t.has(n)?a=!0:"STEP"!==n.getInterpolation()&&"LINEAR"!==n.getInterpolation()||(o.add(n.getInput()),o.add(n.getOutput()),Ie(n,r))}for(const t of Array.from(o.values()))t.listParents().some(t=>!(t instanceof e.Root))||t.dispose();t.getRoot().listAccessors().length>s&&!g(n,"resample","dedup")&&i.warn('resample: Resampling required copying accessors, some of which may be duplicates. Consider using "dedup" to consolidate any duplicates.'),a&&i.warn("resample: Skipped optimizing morph target keyframes, not yet supported."),i.debug("resample: Complete.")})},exports.sequence=function(t=Me){const r={...Me,...t};return l("sequence",t=>{const n=t.getLogger(),o=t.getRoot(),s=r.fps,i=o.listNodes().filter(e=>e.getName().match(r.pattern));r.sort&&i.sort((e,t)=>e.getName()>t.getName()?1:-1);const a=t.createAnimation(r.name),c=o.listBuffers()[0];i.forEach((r,n)=>{let o,u;0===n?(o=[n/s,(n+1)/s],u=[1,1,1,0,0,0]):n===i.length-1?(o=[(n-1)/s,n/s],u=[0,0,0,1,1,1]):(o=[(n-1)/s,n/s,(n+1)/s],u=[0,0,0,1,1,1,0,0,0]);const l=t.createAccessor().setArray(new Float32Array(o)).setBuffer(c),g=t.createAccessor().setArray(new Float32Array(u)).setBuffer(c).setType(e.Accessor.Type.VEC3),f=t.createAnimationSampler().setInterpolation(e.AnimationSampler.Interpolation.STEP).setInput(l).setOutput(g),p=t.createAnimationChannel().setTargetNode(r).setTargetPath(e.AnimationChannel.TargetPath.SCALE).setSampler(f);a.addSampler(f).addChannel(p)}),n.debug("sequence: Complete.")})},exports.simplify=t=>{const r={...Le,...t},n=r.simplifier;if(!n)throw new Error('simplify: simplifier dependency required — install "meshoptimizer".');return l("simplify",function(t,o){try{const s=t.getLogger();return Promise.resolve(n.ready).then(function(){return Promise.resolve(t.transform(we({overwrite:!1}))).then(function(){function n(){s.debug("simplify: Complete.")}for(const n of t.getRoot().listMeshes())for(const o of n.listPrimitives()){if(o.getMode()!==e.Primitive.Mode.TRIANGLES)return void s.warn(`simplify: Skipping primitive of mesh "${n.getName()}": Requires TRIANGLES draw mode.`);qe(t,o,r)}const i=function(){if(!g(o,"simplify","dedup"))return Promise.resolve(t.transform(b({propertyTypes:[e.PropertyType.ACCESSOR]}))).then(function(){})}();return i&&i.then?i.then(n):n()})})}catch(e){return Promise.reject(e)}})},exports.simplifyPrimitive=qe,exports.squoosh=Ze,exports.tangents=function(t=Je){if(!t.generateTangents)throw new Error('tangents: generateTangents callback required — install "mikktspace".');const r={...Je,...t};return l("tangents",t=>{const n=t.getLogger(),o=new Map,s=new Map;let i=0;for(const a of t.getRoot().listMeshes()){const c=a.getName(),u=a.listPrimitives();for(let a=0;a<u.length;a++){const l=u[a];if(!Ye(l,n,c,a,r.overwrite))continue;const g=Qe(l),f=l.getAttribute("POSITION").getArray(),p=l.getAttribute("NORMAL").getArray(),m=l.getAttribute(g).getArray(),d=o.get(f)||e.uuid();o.set(f,d);const h=o.get(p)||e.uuid();o.set(p,h);const y=o.get(m)||e.uuid();o.set(m,y);const T=l.getAttribute("TANGENT");T&&2===T.listParents().length&&T.dispose();const A=`${d}|${h}|${y}`;let E=s.get(A);if(E){n.debug(`tangents: Found cache for primitive ${a} of mesh "${c}".`),l.setAttribute("TANGENT",E),i++;continue}n.debug(`tangents: Generating for primitive ${a} of mesh "${c}".`);const S=l.getAttribute("POSITION").getBuffer(),P=r.generateTangents(f instanceof Float32Array?f:new Float32Array(f),p instanceof Float32Array?p:new Float32Array(p),m instanceof Float32Array?m:new Float32Array(m));for(let e=3;e<P.length;e+=4)P[e]*=-1;E=t.createAccessor().setBuffer(S).setArray(P).setType("VEC4"),l.setAttribute("TANGENT",E),s.set(A,E),i++}}i?n.debug("tangents: Complete."):n.warn("tangents: No qualifying primitives found. See debug output.")})},exports.textureResize=function(e=it){const r={...it,...e};return l(ot,function(e){try{let o;function n(e){s.debug(`${ot}: Complete.`)}const s=e.getLogger(),a=function(e,t,r){if("function"==typeof e[et]){var n,o,s,i=e[et]();if(function e(a){try{for(;!((n=i.next()).done||r&&r());)if((a=t(n.value))&&a.then){if(!nt(a))return void a.then(e,s||(s=tt.bind(null,o=new rt,2)));a=a.v}o?tt(o,1,a):o=a}catch(e){tt(o||(o=new rt),2,e)}}(),i.return){var a=function(e){try{n.done||i.return()}catch(e){}return e};if(o&&o.then)return o.then(a,function(e){throw a(e)});a()}return o}if(!("length"in e))throw new TypeError("Object is not iterable");for(var c=[],u=0;u<e.length;u++)c.push(e[u]);return function(e,t,r){var n,o,s=-1;return function i(a){try{for(;++s<e.length&&(!r||!r());)if((a=t(s))&&a.then){if(!nt(a))return void a.then(i,o||(o=tt.bind(null,n=new rt,2)));a=a.v}n?tt(n,1,a):n=a}catch(e){tt(n||(n=new rt),2,e)}}(),n}(c,function(e){return t(c[e])},r)}(e.getRoot().listTextures(),function(n){const o=n.getName(),a=n.getURI();if(r.pattern&&!r.pattern.test(o)&&!r.pattern.test(a))return void s.debug(`${ot}: Skipping, excluded by "pattern" parameter.`);if("image/png"!==n.getMimeType()&&"image/jpeg"!==n.getMimeType())return void s.warn(`${ot}: Skipping, unsupported texture type "${n.getMimeType()}".`);const u=Ue(e,n);if(r.slots&&!u.some(e=>r.slots?.test(e)))return void s.debug(`${ot}: Skipping, [${u.join(", ")}] excluded by "slots" parameter.`);const[l,g]=r.size,[f,p]=n.getSize();if(f<=l&&p<=g)return void s.debug(`${ot}: Skipping, not within size range.`);let m=f,d=p;m>l&&(d=Math.floor(d*(l/m)),m=l),d>g&&(m=Math.floor(m*(g/d)),d=g);const h=n.getImage();return Promise.resolve(t.getPixels(h,n.getMimeType())).then(function(e){const l=c.default(new Uint8Array(m*d*4),[m,d,4]);s.debug(`${ot}: Resizing "${a||o}", ${e.shape} → ${l.shape}...`),s.debug(`${ot}: Slots → [${u.join(", ")}]`);try{r.filter===exports.TextureResizeFilter.LANCZOS3?i.lanczos3(e,l):i.lanczos2(e,l)}catch(e){if(e instanceof Error)return void s.warn(`${ot}: Failed to resize "${a||o}": "${e.message}".`);throw e}const g=n.setImage;return Promise.resolve(t.savePixels(l,n.getMimeType())).then(function(e){g.call(n,e)})})},function(){return o});return Promise.resolve(a&&a.then?a.then(n):n())}catch(e){return Promise.reject(e)}})},exports.unlit=()=>e=>{const t=e.createExtension(r.MaterialsUnlit).createUnlit();e.getRoot().listMaterials().forEach(e=>{e.setExtension("KHR_materials_unlit",t)})},exports.unpartition=(e=at)=>l("unpartition",function(e){try{const t=e.getLogger(),r=e.getRoot().listBuffers()[0];return e.getRoot().listAccessors().forEach(e=>e.setBuffer(r)),e.getRoot().listBuffers().forEach((e,t)=>t>0?e.dispose():null),t.debug("unpartition: Complete."),Promise.resolve()}catch(e){return Promise.reject(e)}}),exports.unweld=ye,exports.webp=function(e){const t={...Ge,...e};return function(e){try{return Promise.resolve(Ze(t)(e)).then(function(){e.getRoot().listTextures().some(e=>e.getMimeType()===ke[Fe.WEBP])&&e.createExtension(r.TextureWebP).setRequired(!0)})}catch(e){return Promise.reject(e)}}},exports.weld=we;
//# sourceMappingURL=functions.js.map
