import{Primitive as e,bounds as t,PropertyType as n,BufferUtils as o,Root as r,Texture as s,ExtensionProperty as i,ImageUtils as a,MathUtils as c,Node as l,AnimationChannel as g,Scene as u,Accessor as f,AnimationSampler as p,Material as m,TextureChannel as d,uuid as h}from"@gltf-transform/core";export{bounds}from"@gltf-transform/core";import{getPixels as A,savePixels as y}from"ndarray-pixels";import{MeshQuantization as E,DracoMeshCompression as T,MeshGPUInstancing as S,MeshoptCompression as I,MaterialsIOR as b,MaterialsSpecular as w,MaterialsPBRSpecularGlossiness as M,TextureWebP as R,MaterialsUnlit as N}from"@gltf-transform/extensions";import{invert as O,fromRotationTranslationScale as C,fromScaling as P,multiply as x}from"gl-matrix/mat4";import{transformMat4 as $,min as z,scale as v,max as L,normalize as q}from"gl-matrix/vec3";import _ from"ndarray";import{lanczos3 as k,lanczos2 as G}from"ndarray-lanczos";function B(){return(B=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(e[o]=n[o])}return e}).apply(this,arguments)}function F(e,t){return Object.defineProperty(t,"name",{value:e}),t}function U(e,t,n){return!!e&&e.stack.lastIndexOf(t)<e.stack.lastIndexOf(n)}async function W(e,t,n){if(!e)return null;const o=e.getImage();if(!o)return null;const r=await A(o,e.getMimeType());for(let e=0;e<r.shape[0];++e)for(let t=0;t<r.shape[1];++t)n(r,e,t);const s=await y(r,"image/png");return t.setImage(s).setMimeType("image/png")}class j{constructor(){this._map=new Map}get size(){return this._map.size}has(e){return this._map.has(e)}add(e,t){let n=this._map.get(e);return n||(n=new Set,this._map.set(e,n)),n.add(t),this}get(e){return this._map.get(e)||new Set}keys(){return this._map.keys()}}function V(e,t=2){if(0===e)return"0 Bytes";const n=t<0?0:t,o=Math.floor(Math.log(e)/Math.log(1e3));return parseFloat((e/Math.pow(1e3,o)).toFixed(n))+" "+["Bytes","KB","MB","GB","TB","PB","EB","ZB","YB"][o]}function H(e){return e.toString().replace(/\B(?=(\d{3})+(?!\d))/g,",")}function D(e,t){return`${H(e)} → ${H(t)} (${function(e,t,n=2){return(e>t?"–":"+")+(Math.abs(e-t)/e*100).toFixed(n)+"%"}(e,t)})`}function X(e){const t=[];for(const n of e.listAttributes())t.push(n);for(const n of e.listTargets())for(const e of n.listAttributes())t.push(e);return Array.from(new Set(t))}function K(e,t,n){e.swap(t,n);for(const o of e.listTargets())o.swap(t,n)}function Z(e,t,n){const o=e.getElementSize(),r=e.getCount(),s=e.getArray(),i=s.slice(0,n*o);for(let e=0;e<r;e++)for(let n=0;n<o;n++)i[t[e]*o+n]=s[e*o+n];e.setArray(i)}function J(e,t=e){const n=t<=65534?new Uint16Array(e):new Uint32Array(e);for(let e=0;e<n.length;e++)n[e]=e;return n}const Q={pivot:"center"};function Y(e=Q){const n=B({},Q,e);return F("center",e=>{const o=e.getLogger(),r=e.getRoot(),s=r.listAnimations().length>0||r.listSkins().length>0;e.getRoot().listScenes().forEach((i,a)=>{let c;if(o.debug(`center: Scene ${a+1} / ${r.listScenes().length}.`),"string"==typeof n.pivot){const e=t(i);c=[(e.max[0]-e.min[0])/2+e.min[0],(e.max[1]-e.min[1])/2+e.min[1],(e.max[2]-e.min[2])/2+e.min[2]],"above"===n.pivot&&(c[1]=e.max[1]),"below"===n.pivot&&(c[1]=e.min[1])}else c=n.pivot;o.debug(`center: Pivot "${c.join(", ")}".`);const l=[-1*c[0],-1*c[1],-1*c[2]];if(s){o.debug("center: Model contains animation or skin. Adding a wrapper node.");const t=e.createNode("Pivot").setTranslation(l);i.listChildren().forEach(e=>t.addChild(e)),i.addChild(t)}else o.debug("center: Skipping wrapper, offsetting all root nodes."),i.listChildren().forEach(e=>{const t=e.getTranslation();e.setTranslation([t[0]+l[0],t[1]+l[1],t[2]+l[2]])})}),o.debug("center: Complete.")})}const ee="colorspace";function te(e){return F(ee,t=>{const n=t.getLogger();if("linear"===e.inputEncoding)return void n.info(`${ee}: Vertex colors already linear. Skipping conversion.`);if("sRGB"!==e.inputEncoding)return void n.error(`${ee}: Unknown input encoding "${e.inputEncoding}" – should be "sRGB" or "linear". Skipping conversion.`);const o=new Set;function r(e){return e<.04045?.0773993808*e:Math.pow(.9478672986*e+.0521327014,2.4)}function s(e){const t=[0,0,0];let n;for(let s=0;n=e.getAttribute(`COLOR_${s}`);s++)if(!o.has(n)){for(let e=0;e<n.getCount();e++)n.getElement(e,t),t[0]=r(t[0]),t[1]=r(t[1]),t[2]=r(t[2]),n.setElement(e,t);o.add(n)}}t.getRoot().listMeshes().forEach(e=>e.listPrimitives().forEach(s)),n.debug(`${ee}: Complete.`)})}const ne={propertyTypes:[n.ACCESSOR,n.MESH,n.TEXTURE,n.MATERIAL]},oe=function(e=ne){const t=B({},ne,e),s=new Set(t.propertyTypes);for(const e of t.propertyTypes)if(!ne.propertyTypes.includes(e))throw new Error(`dedup: Unsupported deduplication on type "${e}".`);return F("dedup",e=>{const t=e.getLogger();s.has(n.ACCESSOR)&&function(e,t){const n=new Set,r=new Set,s=new Set,i=new Set,a=t.getRoot().listMeshes();a.forEach(e=>{e.listPrimitives().forEach(e=>{e.listAttributes().forEach(e=>r.add(e));const t=e.getIndices();t&&n.add(t)})});for(const e of t.getRoot().listAnimations())for(const t of e.listSamplers()){const e=t.getInput(),n=t.getOutput();e&&s.add(e),n&&i.add(n)}function c(e){const t=new Map;for(let n=0;n<e.length;n++){const r=e[n],s=o.toView(r.getArray());if(!t.has(r))for(let n=0;n<e.length;n++){const i=e[n];r!==i&&(t.has(i)||r.getType()===i.getType()&&r.getComponentType()===i.getComponentType()&&r.getCount()===i.getCount()&&r.getNormalized()===i.getNormalized()&&o.equals(s,o.toView(i.getArray()))&&t.set(i,r))}}return t}const l=c(Array.from(n));e.debug(`dedup: Found ${l.size} duplicates among ${n.size} indices.`);const g=c(Array.from(r));e.debug(`dedup: Found ${g.size} duplicates among ${r.size} attributes.`);const u=c(Array.from(s)),f=c(Array.from(i));e.debug(`dedup: Found ${u.size+f.size} duplicates among ${s.size+i.size} animation accessors.`),a.forEach(e=>{e.listPrimitives().forEach(e=>{e.listAttributes().forEach(t=>{g.has(t)&&e.swap(t,g.get(t))});const t=e.getIndices();t&&l.has(t)&&e.swap(t,l.get(t))})}),Array.from(l.keys()).forEach(e=>e.dispose()),Array.from(g.keys()).forEach(e=>e.dispose());for(const e of t.getRoot().listAnimations())for(const t of e.listSamplers()){const e=t.getInput(),n=t.getOutput();e&&u.has(e)&&t.swap(e,u.get(e)),n&&f.has(n)&&t.swap(n,f.get(n))}Array.from(u.keys()).forEach(e=>e.dispose()),Array.from(f.keys()).forEach(e=>e.dispose())}(t,e),s.has(n.MESH)&&function(e,t){const o=t.getRoot(),r=new Map;o.listAccessors().forEach((e,t)=>r.set(e,t)),o.listMaterials().forEach((e,t)=>r.set(e,t));const s=o.listMeshes().length,i=new Map;for(const e of o.listMeshes()){const t=[];for(const n of e.listPrimitives())t.push(re(n,r));const o=t.join(";");if(i.has(o)){const t=i.get(o);e.listParents().forEach(o=>{o.propertyType!==n.ROOT&&o.swap(e,t)}),e.dispose()}else i.set(o,e)}e.debug(`dedup: Found ${s-i.size} duplicates among ${s} meshes.`)}(t,e),s.has(n.TEXTURE)&&function(e,t){const n=t.getRoot(),s=n.listTextures(),i=new Map;for(let e=0;e<s.length;e++){const t=s[e],n=t.getImage();if(!i.has(t))for(let e=0;e<s.length;e++){const r=s[e],a=r.getImage();if(t===r)continue;if(i.has(r))continue;if(t.getMimeType()!==r.getMimeType())continue;const c=t.getSize(),l=r.getSize();c&&l&&c[0]===l[0]&&c[1]===l[1]&&n&&a&&o.equals(n,a)&&i.set(r,t)}}e.debug(`dedup: Found ${i.size} duplicates among ${n.listTextures().length} textures.`),Array.from(i.entries()).forEach(([e,t])=>{e.listParents().forEach(n=>{n instanceof r||n.swap(e,t)}),e.dispose()})}(t,e),s.has(n.MATERIAL)&&function(e,t){const n=t.getRoot(),o=n.listMaterials(),s=new Map,i=new Set(["name"]);for(let e=0;e<o.length;e++){const t=o[e];if(!s.has(t))for(let e=0;e<o.length;e++){const n=o[e];t!==n&&(s.has(n)||t.equals(n,i)&&s.set(n,t))}}e.debug(`dedup: Found ${s.size} duplicates among ${n.listMaterials().length} materials.`),Array.from(s.entries()).forEach(([e,t])=>{e.listParents().forEach(n=>{n instanceof r||n.swap(e,t)}),e.dispose()})}(t,e),t.debug("dedup: Complete.")})};function re(t,n){const o=[];for(const e of t.listSemantics()){const r=t.getAttribute(e);o.push(e+":"+n.get(r))}if(t instanceof e){const e=t.getIndices();e&&o.push("indices:"+n.get(e));const r=t.getMaterial();r&&o.push("material:"+n.get(r)),o.push("mode:"+t.getMode());for(const e of t.listTargets())o.push("target:"+re(e,n))}return o.join(",")}const se={pattern:/^((?!JOINTS_).)*$/};function ie(e=se){const t=B({},se,e);return F("dequantize",e=>{const n=e.getLogger();for(const n of e.getRoot().listMeshes())for(const e of n.listPrimitives())ae(e,t);e.createExtension(E).dispose(),n.debug("dequantize: Complete.")})}function ae(e,t){for(const n of e.listSemantics())ce(n,e.getAttribute(n),t);for(const n of e.listTargets())for(const e of n.listSemantics())ce(e,n.getAttribute(e),t)}function ce(e,t,n){if(!t.getArray())return;if(!n.pattern.test(e))return;if(t.getComponentSize()>=4)return;const o=t.getArray(),r=new Float32Array(o.length);for(let e=0,n=t.getCount(),s=[];e<n;e++)s=t.getElement(e,s),t.setArray(r).setElement(e,s).setArray(o);t.setArray(r).setNormalized(!1)}const le={method:"edgebreaker",encodeSpeed:5,decodeSpeed:5,quantizePosition:14,quantizeNormal:10,quantizeColor:8,quantizeTexcoord:12,quantizeGeneric:12,quantizationVolume:"mesh"},ge=e=>{const t=B({},le,e);return e=>{e.createExtension(T).setRequired(!0).setEncoderOptions({method:"edgebreaker"===t.method?T.EncoderMethod.EDGEBREAKER:T.EncoderMethod.SEQUENTIAL,encodeSpeed:t.encodeSpeed,decodeSpeed:t.decodeSpeed,quantizationBits:{POSITION:t.quantizePosition,NORMAL:t.quantizeNormal,COLOR:t.quantizeColor,TEX_COORD:t.quantizeTexcoord,GENERIC:t.quantizeGeneric},quantizationVolume:t.quantizationVolume})}};function ue(e){return{scenes:fe(e),meshes:pe(e),materials:me(e),textures:de(e),animations:he(e)}}function fe(e){return{properties:e.getRoot().listScenes().map(e=>{const n=e.listChildren()[0],o=t(e);return{name:e.getName(),rootName:n?n.getName():"",bboxMin:Ee(o.min),bboxMax:Ee(o.max)}})}}function pe(t){return{properties:t.getRoot().listMeshes().map(t=>{const o=t.listParents().filter(e=>e.propertyType!==n.ROOT).length;let r=0,s=0;const i=new Set,a=new Set,c=new Set;t.listPrimitives().forEach(t=>{for(const e of t.listSemantics()){const n=t.getAttribute(e);i.add(e+":"+Te(n)),c.add(n)}for(const e of t.listTargets())e.listAttributes().forEach(e=>c.add(e));const n=t.getIndices();n&&(a.add(Te(n)),c.add(n)),s+=t.listAttributes()[0].getCount(),r+=function(t){const n=t.getIndices(),o=t.getAttribute("POSITION");switch(t.getMode()){case e.Mode.POINTS:return o.getCount();case e.Mode.LINES:return n?n.getCount()/2:o.getCount()/2;case e.Mode.LINE_LOOP:return o.getCount();case e.Mode.LINE_STRIP:return o.getCount()-1;case e.Mode.TRIANGLES:return n?n.getCount()/3:o.getCount()/3;case e.Mode.TRIANGLE_STRIP:case e.Mode.TRIANGLE_FAN:return o.getCount()-2;default:throw new Error("Unexpected mode: "+t.getMode())}}(t)});let l=0;Array.from(c).forEach(e=>l+=e.getArray().byteLength);const g=t.listPrimitives().map(e=>Ae[e.getMode()]);return{name:t.getName(),mode:Array.from(new Set(g)),primitives:t.listPrimitives().length,glPrimitives:r,vertices:s,indices:Array.from(a).sort(),attributes:Array.from(i).sort(),instances:o,size:l}})}}function me(e){return{properties:e.getRoot().listMaterials().map(t=>{const o=t.listParents().filter(e=>e.propertyType!==n.ROOT).length,r=new Set(t.listExtensions()),a=e.getGraph().listEdges().filter(e=>{const n=e.getChild(),o=e.getParent();return n instanceof s&&o===t||!!(n instanceof s&&o instanceof i&&r.has(o))}).map(e=>e.getName());return{name:t.getName(),instances:o,textures:a,alphaMode:t.getAlphaMode(),doubleSided:t.getDoubleSided()}})}}function de(e){return{properties:e.getRoot().listTextures().map(t=>{const o=t.listParents().filter(e=>e.propertyType!==n.ROOT).length,r=e.getGraph().listParentEdges(t).filter(e=>e.getParent().propertyType!==n.ROOT).map(e=>e.getName()),s=a.getSize(t.getImage(),t.getMimeType());return{name:t.getName(),uri:t.getURI(),slots:Array.from(new Set(r)),instances:o,mimeType:t.getMimeType(),resolution:s?s.join("x"):"",size:t.getImage().byteLength,gpuSize:a.getMemSize(t.getImage(),t.getMimeType())}})}}function he(e){return{properties:e.getRoot().listAnimations().map(e=>{let t=Infinity,n=-Infinity;e.listSamplers().forEach(e=>{const o=e.getInput();o&&(t=Math.min(t,o.getMin([])[0]),n=Math.max(n,o.getMax([])[0]))});let o=0,r=0;const s=new Set;return e.listSamplers().forEach(e=>{const t=e.getInput(),n=e.getOutput();t&&(r+=t.getCount(),s.add(t),n&&s.add(n))}),Array.from(s).forEach(e=>{o+=e.getArray().byteLength}),{name:e.getName(),channels:e.listChannels().length,samplers:e.listSamplers().length,duration:Math.round(1e3*(n-t))/1e3,keyframes:r,size:o}})}}const Ae=["POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN"],ye={Float32Array:"f32",Uint32Array:"u32",Uint16Array:"u16",Uint8Array:"u8",Int32Array:"i32",Int16Array:"i16",Int8Array:"i8"};function Ee(e){for(let t=0;t<e.length;t++)e[t].toFixed&&(e[t]=Number(e[t].toFixed(5)));return e}function Te(e){const t=e.getArray();return(ye[t.constructor.name]||"?")+(e.getNormalized()?"_norm":"")}const Se={};function Ie(e=Se){return B({},Se,e),F("instance",e=>{const t=e.getLogger(),n=e.getRoot(),o=e.createExtension(S);if(n.listAnimations().length)throw new Error("instance: Instancing is not currently supported for animated models.");let r=0,s=0;for(const i of n.listScenes()){const n=new Map;i.traverse(e=>{const t=e.getMesh();t&&n.set(t,(n.get(t)||new Set).add(e))});const a=[];for(const l of Array.from(n.keys())){const g=Array.from(n.get(l));if(g.length<2)continue;if(g.some(e=>e.getSkin()))continue;const u=we(e,o,l,g.length),f=u.getAttribute("TRANSLATION"),p=u.getAttribute("ROTATION"),m=u.getAttribute("SCALE"),d=e.createNode().setMesh(l).setExtension("EXT_mesh_gpu_instancing",u);i.addChild(d);let h=!1,A=!1,y=!1;for(let e=0;e<g.length;e++){let t,n,o;const r=g[e];f.setElement(e,t=r.getWorldTranslation()),p.setElement(e,n=r.getWorldRotation()),m.setElement(e,o=r.getWorldScale()),c.eq(t,[0,0,0])||(h=!0),c.eq(n,[0,0,0,1])||(A=!0),c.eq(o,[1,1,1])||(y=!0),r.setMesh(null),a.push(r)}h||f.dispose(),A||p.dispose(),y||m.dispose(),be(a,t),r++,s+=g.length}}r>0?t.info(`instance: Created ${r} batches, with ${s} total instances.`):(t.info("instance: No meshes with multiple parent nodes were found."),o.dispose()),t.debug("instance: Complete.")})}function be(e,t){let n,o=0;for(;n=e.pop();){if(n.listChildren().length||n.getCamera()||n.getMesh()||n.getSkin()||n.listExtensions().length)continue;const t=n.getParent();t instanceof l&&e.push(t),n.dispose(),o++}t.debug(`instance: Removed ${o} unused nodes.`)}function we(e,t,n,o){const r=n.listPrimitives()[0].getAttribute("POSITION").getBuffer(),s=e.createAccessor().setType("VEC3").setArray(new Float32Array(3*o)).setBuffer(r),i=e.createAccessor().setType("VEC4").setArray(new Float32Array(4*o)).setBuffer(r),a=e.createAccessor().setType("VEC3").setArray(new Float32Array(3*o)).setBuffer(r);return t.createInstancedMesh().setAttribute("TRANSLATION",s).setAttribute("ROTATION",i).setAttribute("SCALE",a)}const Me={propertyTypes:[n.NODE,n.SKIN,n.MESH,n.CAMERA,n.PRIMITIVE,n.PRIMITIVE_TARGET,n.ANIMATION,n.MATERIAL,n.TEXTURE,n.ACCESSOR,n.BUFFER],keepLeaves:!1},Re=function(e=Me){const t=B({},Me,e),o=t.propertyTypes;return F("prune",e=>{const s=e.getLogger(),i=e.getRoot(),a=e.getGraph(),c={};if(t.keepLeaves||i.listScenes().forEach(function e(t){if(t.listChildren().forEach(e),t instanceof u)return;const n=a.listParentEdges(t).some(e=>"targetNode"===e.getName());0!==a.listChildren(t).length||n||(t.dispose(),p(t))}),o.includes(n.NODE)&&i.listNodes().forEach(l),o.includes(n.SKIN)&&i.listSkins().forEach(l),o.includes(n.MESH)&&i.listMeshes().forEach(l),o.includes(n.CAMERA)&&i.listCameras().forEach(l),o.includes(n.PRIMITIVE)&&f(a,n.PRIMITIVE),o.includes(n.PRIMITIVE_TARGET)&&f(a,n.PRIMITIVE_TARGET),o.includes(n.ANIMATION))for(const e of i.listAnimations()){for(const t of e.listChannels())t.getTargetNode()||(t.dispose(),p(t));if(e.listChannels().length)e.listSamplers().forEach(l);else{const t=e.listSamplers();l(e),t.forEach(l)}}if(o.includes(n.MATERIAL)&&i.listMaterials().forEach(l),o.includes(n.TEXTURE)&&i.listTextures().forEach(l),o.includes(n.ACCESSOR)&&i.listAccessors().forEach(l),o.includes(n.BUFFER)&&i.listBuffers().forEach(l),Object.keys(c).length){const e=Object.keys(c).map(e=>`${e} (${c[e]})`).join(", ");s.info(`prune: Removed types... ${e}`)}else s.info("prune: No unused properties found.");function l(e){e.listParents().filter(e=>!(e instanceof r||e instanceof g)).length||(e.dispose(),p(e))}function f(e,t){e.listEdges().map(e=>e.getParent()).filter(e=>e.propertyType===t).forEach(l)}function p(e){c[e.propertyType]=c[e.propertyType]||0,c[e.propertyType]++}s.debug("prune: Complete.")})},Ne={target:"size"};function Oe(t){const o=B({},Ne,t),r=o.encoder;if(!r)throw new Error('reorder: encoder dependency required — install "meshoptimizer".');return F("reorder",async t=>{const s=t.getLogger();await r.ready;const i=Ce(t);for(const t of i.indicesToAttributes.keys()){const n=t.clone();let s=n.getArray().slice();s instanceof Uint32Array||(s=new Uint32Array(s));const[a,c]=r.reorderMesh(s,i.indicesToMode.get(t)===e.Mode.TRIANGLES,"size"===o.target);n.setArray(c<=65534?new Uint16Array(s):s);for(const e of i.indicesToAttributes.get(t)){const o=e.clone();Z(o,a,c);for(const r of i.attributesToPrimitives.get(e))if(r.getIndices()===t&&r.swap(t,n),r.getIndices()===n){r.swap(e,o);for(const t of r.listTargets())t.swap(e,o)}}}await t.transform(Re({propertyTypes:[n.ACCESSOR]})),i.indicesToAttributes.size?s.debug("reorder: Complete."):s.warn("reorder: No qualifying primitives found; may need to weld first.")})}function Ce(e){const t=new j,n=new Map,o=new j;for(const r of e.getRoot().listMeshes())for(const e of r.listPrimitives()){const r=e.getIndices();if(r){n.set(r,e.getMode());for(const n of X(e))t.add(r,n),o.add(n,e)}}return{indicesToAttributes:t,indicesToMode:n,attributesToPrimitives:o}}const Pe=[Int8Array,Int16Array,Int32Array],{TRANSLATION:xe,ROTATION:$e,SCALE:ze,WEIGHTS:ve}=g.TargetPath,Le=[xe,$e,ze],qe={pattern:/.*/,quantizationVolume:"mesh",quantizePosition:14,quantizeNormal:10,quantizeTexcoord:12,quantizeColor:8,quantizeWeight:8,quantizeGeneric:12,normalizeWeights:!0},_e=(e=qe)=>{const t=B({},qe,e);return F("quantize",async e=>{const o=e.getLogger(),r=e.getRoot();let s;e.createExtension(E).setRequired(!0),"scene"===t.quantizationVolume&&(s=Ge(function(e){const t=e[0];for(const n of e)z(t.min,t.min,n.min),L(t.max,t.max,n.max);return t}(r.listMeshes().map(Ve))));for(const n of e.getRoot().listMeshes()){"mesh"===t.quantizationVolume&&(s=Ge(Ve(n))),s&&t.pattern.test("POSITION")&&(Be(e,n,s),Ue(n,1/s.scale));for(const o of n.listPrimitives()){ke(e,o,s,t);for(const n of o.listTargets())ke(e,n,s,t)}}await e.transform(Re({propertyTypes:[n.ACCESSOR,n.SKIN,n.MATERIAL]}),oe({propertyTypes:[n.ACCESSOR,n.MATERIAL]})),o.debug("quantize: Complete.")})};function ke(t,n,o,r){const s=t.getLogger();for(const t of n.listSemantics()){if(!r.pattern.test(t))continue;const i=n.getAttribute(t),{bits:a,ctor:c}=je(t,i,s,r);if(!c)continue;if(a<8||a>16)throw new Error("quantize: Requires bits = 8–16.");if(i.getComponentSize()<=a/8)continue;const l=i.clone();if("POSITION"===t){const t=o.scale,r=[];n instanceof e?O(r,De(o)):P(r,[1/t,1/t,1/t]);for(let e=0,t=[0,0,0],n=l.getCount();e<n;e++)l.getElement(e,t),l.setElement(e,$(t,t,r))}We(l,c,a),n.swap(i,l)}if(r.normalizeWeights&&n.getAttribute("WEIGHTS_0")&&function(e){const t=e.getAttribute("POSITION").getCount(),n=[];for(let o=0;o<t;o++){let t,r=0,s=Infinity,i=-1,a=null,c=0;for(;t=e.getAttribute("WEIGHTS_"+c++);){t.getElement(o,n);for(let e=0;e<n.length;e++)r+=n[e],n[e]>0&&n[e]<s&&(a=t,s=n[e],i=e)}a&&1!==r&&(a.getElement(o,n),n[i]+=1-r,a.setElement(o,n))}}(n),n instanceof e&&n.getIndices()&&n.listAttributes().length&&n.listAttributes()[0].getCount()<65535){const e=n.getIndices();e.setArray(new Uint16Array(e.getArray()))}}function Ge(e){const{min:t,max:n}=e,o=Math.max((n[0]-t[0])/2,(n[1]-t[1])/2,(n[2]-t[2])/2);return{offset:[t[0]+(n[0]-t[0])/2,t[1]+(n[1]-t[1])/2,t[2]+(n[2]-t[2])/2],scale:o}}function Be(e,t,n){const o=De(n);for(const r of t.listParents()){if(!(r instanceof l))continue;const s=r.listParents().filter(e=>e instanceof g),i=s.some(e=>Le.includes(e.getTargetPath())),a=r.listChildren().length>0;if(r.getSkin()){r.setSkin(Fe(r.getSkin(),n));continue}let c;a||i?(c=e.createNode("").setMesh(t),r.addChild(c).setMesh(null),s.filter(e=>e.getTargetPath()===ve).forEach(e=>e.setTargetNode(c))):c=r;const u=c.getMatrix();x(u,u,o),c.setMatrix(u)}}function Fe(e,t){e=e.clone();const n=De(t),o=e.getInverseBindMatrices().clone(),r=[];for(let e=0,t=o.getCount();e<t;e++)o.getElement(e,r),x(r,r,n),o.setElement(e,r);return e.setInverseBindMatrices(o)}function Ue(e,t){for(const n of e.listPrimitives()){let e=n.getMaterial();if(!e)continue;let o=e.getExtension("KHR_materials_volume");!o||o.getThicknessFactor()<=0||(o=o.clone().setThicknessFactor(o.getThicknessFactor()*t),e=e.clone().setExtension("KHR_materials_volume",o),n.setMaterial(e))}}function We(e,t,n){const o=new t(e.getArray().length),r=Pe.includes(t)?1:0,s=n-r,i=8*t.BYTES_PER_ELEMENT-r,a=Math.pow(2,s)-1,c=i-s,l=2*s-i;for(let t=0,n=0,r=[];t<e.getCount();t++){e.getElement(t,r);for(let e=0;e<r.length;e++){let t=Math.round(Math.abs(r[e])*a);t=t<<c|t>>l,o[n++]=t*Math.sign(r[e])}}e.setArray(o).setNormalized(!0)}function je(e,t,n,o){const r=t.getMinNormalized([]),s=t.getMaxNormalized([]);let i,a;if("POSITION"===e)i=o.quantizePosition,a=i<=8?Int8Array:Int16Array;else if("NORMAL"===e||"TANGENT"===e)i=o.quantizeNormal,a=i<=8?Int8Array:Int16Array;else if(e.startsWith("COLOR_"))i=o.quantizeColor,a=i<=8?Uint8Array:Uint16Array;else if(e.startsWith("TEXCOORD_")){if(r.some(e=>e<0)||s.some(e=>e>1))return n.warn(`quantize: Skipping ${e}; out of [0,1] range.`),{bits:-1};i=o.quantizeTexcoord,a=i<=8?Uint8Array:Uint16Array}else{if(e.startsWith("JOINTS_"))return i=Math.max(...t.getMax([]))<=255?8:16,a=i<=8?Uint8Array:Uint16Array,t.getComponentSize()>i/8&&t.setArray(new a(t.getArray())),{bits:-1};if(e.startsWith("WEIGHTS_")){if(r.some(e=>e<0)||s.some(e=>e>1))return n.warn(`quantize: Skipping ${e}; out of [0,1] range.`),{bits:-1};i=o.quantizeWeight,a=i<=8?Uint8Array:Uint16Array}else{if(!e.startsWith("_"))throw new Error(`quantize: Unexpected semantic, "${e}".`);if(r.some(e=>e<-1)||s.some(e=>e>1))return n.warn(`quantize: Skipping ${e}; out of [-1,1] range.`),{bits:-1};i=o.quantizeGeneric,a=a=r.some(e=>e<0)?i<=8?Int8Array:Int16Array:i<=8?Uint8Array:Uint16Array}}return{bits:i,ctor:a}}function Ve(e){const t=[],n=[];for(const o of e.listPrimitives()){const e=o.getAttribute("POSITION");e&&t.push(e);for(const e of o.listTargets()){const t=e.getAttribute("POSITION");t&&n.push(t)}}if(0===t.length)throw new Error('quantize: Missing "POSITION" attribute.');const o=He(t,3);if(n.length>0){const{min:e,max:t}=He(n,3);z(o.min,o.min,z(e,v(e,e,2),[0,0,0])),L(o.max,o.max,L(t,v(t,t,2),[0,0,0]))}return o}function He(e,t){const n=new Array(t).fill(Infinity),o=new Array(t).fill(-Infinity),r=[],s=[];for(const i of e){i.getMinNormalized(r),i.getMaxNormalized(s);for(let e=0;e<t;e++)n[e]=Math.min(n[e],r[e]),o[e]=Math.max(o[e],s[e])}return{min:n,max:o}}function De(e){return C([],[0,0,0,1],e.offset,[e.scale,e.scale,e.scale])}const Xe={level:"high"},Ke=e=>{const t=B({},Xe,e),n=t.encoder;if(!n)throw new Error('meshopt: encoder dependency required — install "meshoptimizer".');return async e=>{await e.transform(Oe({encoder:n,target:"size"}),_e({pattern:"medium"===t.level?/.*/:/^(POSITION|TEXCOORD|JOINTS|WEIGHTS)(_\d+)?$/,quantizePosition:14,quantizeTexcoord:12,quantizeColor:8,quantizeNormal:8})),e.createExtension(I).setRequired(!0).setEncoderOptions({method:"medium"===t.level?I.EncoderMethod.QUANTIZE:I.EncoderMethod.FILTER})}},Ze={};function Je(e=Ze){return B({},Ze,e),F("metalRough",async e=>{const t=e.getLogger();if(!e.getRoot().listExtensionsUsed().map(e=>e.extensionName).includes("KHR_materials_pbrSpecularGlossiness"))return void t.warn("metalRough: KHR_materials_pbrSpecularGlossiness not found on document.");const n=e.createExtension(b),o=e.createExtension(w),r=e.createExtension(M),s=new Set;for(const t of e.getRoot().listMaterials()){const r=t.getExtension("KHR_materials_pbrSpecularGlossiness");if(!r)continue;const i=o.createSpecular().setSpecularFactor(1).setSpecularColorFactor(r.getSpecularFactor());s.add(r.getSpecularGlossinessTexture()),s.add(t.getBaseColorTexture()),s.add(t.getMetallicRoughnessTexture()),t.setBaseColorFactor(r.getDiffuseFactor()).setMetallicFactor(0).setRoughnessFactor(1).setExtension("KHR_materials_ior",n.createIOR().setIOR(1e3)).setExtension("KHR_materials_specular",i);const a=r.getDiffuseTexture();a&&(t.setBaseColorTexture(a),t.getBaseColorTextureInfo().copy(r.getDiffuseTextureInfo()));const c=r.getSpecularGlossinessTexture();if(c){const n=r.getSpecularGlossinessTextureInfo(),o=e.createTexture();await W(c,o,(e,t,n)=>{e.set(t,n,3,255)}),i.setSpecularTexture(o),i.setSpecularColorTexture(o),i.getSpecularTextureInfo().copy(n),i.getSpecularColorTextureInfo().copy(n);const s=r.getGlossinessFactor(),a=e.createTexture();await W(c,a,(e,t,n)=>{const o=255-Math.round(e.get(t,n,3)*s);e.set(t,n,0,0),e.set(t,n,1,o),e.set(t,n,2,0),e.set(t,n,3,255)}),t.setMetallicRoughnessTexture(a),t.getMetallicRoughnessTextureInfo().copy(n)}else i.setSpecularColorFactor(r.getSpecularFactor()),t.setRoughnessFactor(1-r.getGlossinessFactor());t.setExtension("KHR_materials_pbrSpecularGlossiness",null)}r.dispose();for(const e of s)e&&1===e.listParents().length&&e.dispose();t.debug("metalRough: Complete.")})}const Qe={};function Ye(e=Qe){return B({},Qe,e),F("unweld",e=>{const t=e.getLogger(),n=new Map;for(const o of e.getRoot().listMeshes())for(const e of o.listPrimitives()){const o=e.getIndices();if(!o)continue;const r=e.getAttribute("POSITION").getCount();for(const r of e.listAttributes())e.swap(r,et(r,o,t,n)),1===r.listParents().length&&r.dispose();for(const r of e.listTargets())for(const e of r.listAttributes())r.swap(e,et(e,o,t,n)),1===e.listParents().length&&e.dispose();const s=e.getAttribute("POSITION").getCount();t.debug(`unweld: ${D(r,s)} vertices.`),e.setIndices(null),1===o.listParents().length&&o.dispose()}t.debug("unweld: Complete.")})}function et(e,t,n,o){if(o.has(e)&&o.get(e).has(t))return n.debug(`unweld: Cache hit for reused attribute, "${e.getName()}".`),o.get(e).get(t);const r=e.clone(),s=e.getArray().constructor;r.setArray(new s(t.getCount()*e.getElementSize()));const i=[];for(let n=0;n<t.getCount();n++)r.setElement(n,e.getElement(t.getScalar(n),i));return o.has(e)||o.set(e,new Map),o.get(e).set(t,r),r}const tt={overwrite:!1};function nt(e=tt){const t=B({},tt,e);return F("normals",async e=>{const n=e.getLogger();let o=0;await e.transform(Ye());for(const r of e.getRoot().listMeshes())for(const s of r.listPrimitives()){const r=s.getAttribute("POSITION");let i=s.getAttribute("NORMAL");if(t.overwrite&&i)i.dispose();else if(i){n.debug("normals: Skipping primitive: NORMAL found.");continue}i=e.createAccessor().setArray(new Float32Array(3*r.getCount())).setType("VEC3");const a=[0,0,0],c=[0,0,0],l=[0,0,0];for(let e=0;e<r.getCount();e+=3){r.getElement(e+0,a),r.getElement(e+1,c),r.getElement(e+2,l);const t=ot(a,c,l);i.setElement(e+0,t),i.setElement(e+1,t),i.setElement(e+2,t)}s.setAttribute("NORMAL",i),o++}o?n.debug("normals: Complete."):n.warn("normals: No qualifying primitives found. See debug output.")})}function ot(e,t,n){const o=[t[0]-e[0],t[1]-e[1],t[2]-e[2]],r=[n[0]-e[0],n[1]-e[1],n[2]-e[2]];return q([0,0,0],[o[1]*r[2]-o[2]*r[1],o[2]*r[0]-o[0]*r[2],o[0]*r[1]-o[1]*r[0]])}const rt={animations:!0,meshes:!0},st=(e=rt)=>{const t=B({},rt,e);return F("partition",async e=>{const o=e.getLogger();!1!==t.meshes&&function(e,t,n){const o=new Set(e.getRoot().listBuffers().map(e=>e.getURI()));e.getRoot().listMeshes().forEach((r,s)=>{if(Array.isArray(n.meshes)&&!n.meshes.includes(r.getName()))return void t.debug(`partition: Skipping mesh #${s} with name "${r.getName()}".`);t.debug(`partition: Creating buffer for mesh "${r.getName()}".`);const i=e.createBuffer(r.getName()).setURI(it(r.getName()||"mesh",o));r.listPrimitives().forEach(e=>{const t=e.getIndices();t&&t.setBuffer(i),e.listAttributes().forEach(e=>e.setBuffer(i)),e.listTargets().forEach(e=>{e.listAttributes().forEach(e=>e.setBuffer(i))})})})}(e,o,t),!1!==t.animations&&function(e,t,n){const o=new Set(e.getRoot().listBuffers().map(e=>e.getURI()));e.getRoot().listAnimations().forEach((r,s)=>{if(Array.isArray(n.animations)&&!n.animations.includes(r.getName()))return void t.debug(`partition: Skipping animation #${s} with name "${r.getName()}".`);t.debug(`partition: Creating buffer for animation "${r.getName()}".`);const i=e.createBuffer(r.getName()).setURI(it(r.getName()||"animation",o));r.listSamplers().forEach(e=>{const t=e.getInput(),n=e.getOutput();t&&t.setBuffer(i),n&&n.setBuffer(i)})})}(e,o,t),t.meshes||t.animations||o.warn("partition: Select animations or meshes to create a partition."),await e.transform(Re({propertyTypes:[n.BUFFER]})),o.debug("partition: Complete.")})};function it(e,t){let n=`${e}.bin`,o=1;for(;t.has(n);)n=`${e}_${o++}.bin`;return n}const at={tolerance:1e-4},ct=(e=at)=>{const t=B({},at,e);return F("resample",(e,n)=>{const o=new Set,s=e.getRoot().listAccessors().length,i=e.getLogger();let a=!1;for(const n of e.getRoot().listAnimations()){const e=new Set;for(const t of n.listChannels())t.getSampler()&&"weights"===t.getTargetPath()&&e.add(t.getSampler());for(const r of n.listSamplers())e.has(r)?a=!0:"STEP"!==r.getInterpolation()&&"LINEAR"!==r.getInterpolation()||(o.add(r.getInput()),o.add(r.getOutput()),lt(r,t))}for(const e of Array.from(o.values()))e.listParents().some(e=>!(e instanceof r))||e.dispose();e.getRoot().listAccessors().length>s&&!U(n,"resample","dedup")&&i.warn('resample: Resampling required copying accessors, some of which may be duplicates. Consider using "dedup" to consolidate any duplicates.'),a&&i.warn("resample: Skipped optimizing morph target keyframes, not yet supported."),i.debug("resample: Complete.")})};function lt(e,t){const n=e.getInput().clone(),o=e.getOutput().clone(),r=t.tolerance,s=n.getCount()-1,i=[];let a=1;for(let t=1;t<s;++t){const s=n.getScalar(t),l=n.getScalar(t-1),g=n.getScalar(t+1),u=(s-l)/(g-l);let f=!1;if(s!==g&&(1!==t||s!==n.getScalar(0)))for(let n=0;n<o.getElementSize();n++){const s=o.getElement(t,i)[n],a=o.getElement(t-1,i)[n],l=o.getElement(t+1,i)[n];if("LINEAR"===e.getInterpolation()){if(Math.abs(s-(a*(1-(c=u))+l*c))>r){f=!0;break}}else if("STEP"===e.getInterpolation()&&(s!==a||s!==l)){f=!0;break}}f&&(t!==a&&(n.setScalar(a,n.getScalar(t)),o.setElement(a,o.getElement(t,i))),a++)}var c;s>0&&(n.setScalar(a,n.getScalar(s)),o.setElement(a,o.getElement(s,i)),a++),a!==n.getCount()?(n.setArray(n.getArray().slice(0,a)),o.setArray(o.getArray().slice(0,a*o.getElementSize())),e.setInput(n),e.setOutput(o)):(n.dispose(),o.dispose())}const gt={name:"",fps:10,pattern:/.*/,sort:!0};function ut(e=gt){const t=B({},gt,e);return F("sequence",e=>{const n=e.getLogger(),o=e.getRoot(),r=t.fps,s=o.listNodes().filter(e=>e.getName().match(t.pattern));t.sort&&s.sort((e,t)=>e.getName()>t.getName()?1:-1);const i=e.createAnimation(t.name),a=o.listBuffers()[0];s.forEach((t,n)=>{let o,c;0===n?(o=[n/r,(n+1)/r],c=[1,1,1,0,0,0]):n===s.length-1?(o=[(n-1)/r,n/r],c=[0,0,0,1,1,1]):(o=[(n-1)/r,n/r,(n+1)/r],c=[0,0,0,1,1,1,0,0,0]);const l=e.createAccessor().setArray(new Float32Array(o)).setBuffer(a),u=e.createAccessor().setArray(new Float32Array(c)).setBuffer(a).setType(f.Type.VEC3),m=e.createAnimationSampler().setInterpolation(p.Interpolation.STEP).setInput(l).setOutput(u),d=e.createAnimationChannel().setTargetNode(t).setTargetPath(g.TargetPath.SCALE).setSampler(m);i.addSampler(m).addChannel(d)}),n.debug("sequence: Complete.")})}const ft={tolerance:1e-4,overwrite:!0};function pt(t=ft){const o=B({},ft,t);if(o.tolerance>.1||o.tolerance<0)throw new Error("weld: Requires 0 ≤ tolerance ≤ 0.1");return F("weld",async(t,r)=>{const s=t.getLogger();for(const n of t.getRoot().listMeshes())for(const r of n.listPrimitives())r.getIndices()&&!o.overwrite||r.getMode()!==e.Mode.POINTS&&(0===o.tolerance?mt(t,r):dt(t,r,o));U(r,"weld","dedup")||await t.transform(oe({propertyTypes:[n.ACCESSOR]})),s.debug("weld: Complete.")})}function mt(e,t){if(t.getIndices())return;const n=t.listAttributes()[0],o=n.getCount(),r=n.getBuffer(),s=o<=65534?new Uint16Array(o):new Uint32Array(o),i=e.createAccessor().setBuffer(r).setType(f.Type.SCALAR).setArray(s);for(let e=0;e<i.getCount();e++)i.setScalar(e,e);t.setIndices(i)}function dt(e,t,n){const o=e.getLogger(),r=t.getAttribute("POSITION"),s=t.getIndices()||e.createAccessor().setArray(J(r.getCount())),i=new Uint32Array(new Set(s.getArray())),a=Math.max(n.tolerance,Number.EPSILON),c={};for(const e of t.listSemantics()){const n=t.getAttribute(e);c[e]=Et(e,n,a)}var l;o.debug(`weld: Tolerance thresholds: ${l=c,Object.entries(l).map(([e,t])=>`${e}=${t}`).join(", ")}`);const g=[0,0,0],u=[0,0,0];i.sort((e,t)=>(r.getElement(e,g),r.getElement(t,u),g[0]>u[0]?1:-1));const f=J(i.length),p=J(i.length),m=r.getCount();let d=0,h=0;for(let e=0;e<i.length;e++){const n=i[e];for(let o=e-1;o>=0;o--){const e=f[i[o]];if(r.getElement(n,g),r.getElement(e,u),Math.abs(g[0]-u[0])>c.POSITION)break;h++;const s=t.listSemantics().every(o=>Tt(t.getAttribute(o),n,e,c[o])),a=t.listTargets().every(o=>o.listSemantics().every(o=>Tt(t.getAttribute(o),n,e,c[o])));if(s&&a){f[n]=e;break}}p[n]=f[n]===n?d++:p[f[n]]}o.debug(`weld: Iterations per vertex: ${Math.round(h/i.length)} (avg)`),o.debug(`weld: ${D(m,d)} vertices.`);const A=s.getCount(),y=J(A,i.length);for(let e=0;e<A;e++)y[e]=p[s.getScalar(e)];t.setIndices(s.clone().setArray(y)),1===s.listParents().length&&s.dispose();for(const e of t.listAttributes())ht(t,e,p,d);for(const e of t.listTargets())for(const t of e.listAttributes())ht(e,t,p,d)}function ht(e,t,n,o){const r=(s=t.getArray(),i=o*t.getElementSize(),new(0,s.constructor)(i));var s,i;const a=t.clone().setArray(r),c=new Uint8Array(o);for(let e=0,o=[];e<n.length;e++)c[n[e]]||(a.setElement(n[e],t.getElement(e,o)),c[n[e]]=1);e.swap(t,a),1===t.listParents().length&&t.dispose()}const At=[],yt=[];function Et(e,t,n){return"NORMAL"===e||"TANGENT"===e?.5:e.startsWith("COLOR_")?.01:e.startsWith("TEXCOORD_")?1e-4:e.startsWith("JOINTS_")?0:e.startsWith("WEIGHTS_")?.01:(At.length=yt.length=0,t.getMinNormalized(At),t.getMaxNormalized(yt),n*(Math.max(...yt)-Math.min(...At)||1))}function Tt(e,t,n,o,r){e.getElement(t,At),e.getElement(n,yt);for(let t=0,n=e.getElementSize();t<n;t++)if(Math.abs(At[t]-yt[t])>o)return!1;return!0}const St={ratio:.5,error:.001,lockBorder:!1},It=t=>{const o=B({},St,t),r=o.simplifier;if(!r)throw new Error('simplify: simplifier dependency required — install "meshoptimizer".');return F("simplify",async(t,s)=>{const i=t.getLogger();await r.ready,await t.transform(pt({overwrite:!1}));for(const n of t.getRoot().listMeshes())for(const r of n.listPrimitives())r.getMode()===e.Mode.TRIANGLES?bt(t,r,o):i.warn(`simplify: Skipping primitive of mesh "${n.getName()}": Requires TRIANGLES draw mode.`);U(s,"simplify","dedup")||await t.transform(oe({propertyTypes:[n.ACCESSOR]})),i.debug("simplify: Complete.")})};function bt(e,t,n){const o=B({},St,n),r=e.getLogger(),s=t.getAttribute("POSITION"),i=t.getIndices(),a=s.getCount();let c=s.getArray(),l=i.getArray();if(s.getComponentType()!==f.ComponentType.FLOAT)if(s.getNormalized()){const e=c,t=new Float32Array(e.length);for(let n=0,o=s.getCount(),r=[];n<o;n++)r=s.getElement(n,r),s.setArray(t).setElement(n,r).setArray(e);c=t}else c=new Float32Array(c);i.getComponentType()!==f.ComponentType.UNSIGNED_INT&&(l=new Uint32Array(l));const g=3*Math.floor(o.ratio*a/3),[u,p]=o.simplifier.simplify(l,c,3,g,o.error,o.lockBorder?["LockBorder"]:[]),[m,d]=o.simplifier.compactMesh(u);r.debug(`simplify: ${D(s.getCount(),d)} vertices, error: ${p.toFixed(4)}.`);for(const e of X(t)){const n=e.clone();Z(n,m,d),K(t,e,n),1===e.listParents().length&&e.dispose()}const h=i.clone();return h.setArray(a<=65534?new Uint16Array(u):u),t.setIndices(h),1===i.listParents().length&&i.dispose(),t}function wt(e,t){const n=Mt(e,t),o=[];return n&d.R&&o.push(d.R),n&d.G&&o.push(d.G),n&d.B&&o.push(d.B),n&d.A&&o.push(d.A),o}function Mt(e,t){let o=0;for(const r of e.getGraph().listParentEdges(t)){const t=r.getParent();let{channels:s}=r.getAttributes();s&&"baseColorTexture"===r.getName()&&t instanceof m&&t.getAlphaMode()===m.AlphaMode.OPAQUE&&(s&=~d.A),s?o|=s:t.propertyType!==n.ROOT&&e.getLogger().warn(`Missing attribute ".channels" on edge, "${r.getName()}".`)}return o}function Rt(e,t){const n=e.getRoot(),o=e.getGraph().listParentEdges(t).filter(e=>e.getParent()!==n).map(e=>e.getName());return Array.from(new Set(o))}var Nt;!function(e){e.OXIPNG="oxipng",e.MOZJPEG="mozjpeg",e.WEBP="webp"}(Nt||(Nt={}));const Ot={[Nt.OXIPNG]:"image/png",[Nt.MOZJPEG]:"image/jpeg",[Nt.WEBP]:"image/webp"},Ct={jobs:4,formats:/.*/,slots:/.*/,auto:!1},Pt=B({},Ct,{codec:Nt.WEBP}),xt=B({},Ct,{codec:Nt.MOZJPEG,formats:/^image\/jpeg$/}),$t=B({},Ct,{codec:Nt.OXIPNG,formats:/^image\/png$/}),zt=["image/jpeg","image/png","image/webp"];let vt=null,Lt=0;const qt=(e,t)=>(vt||(vt=new e.ImagePool(t)),Lt++,vt),_t=()=>{Lt--,vt&&Lt<=0&&(vt.close(),vt=null)},kt=function(e){const t=B({},Ct,e),n=t.squoosh,o=t.codec;if(!n)throw new Error(`${o}: squoosh dependency required — install "@squoosh/lib".`);return async e=>{const r=e.getLogger(),s=e.getRoot().listTextures(),i=qt(n,t.jobs);await Promise.all(s.map(async(n,s)=>{const a=Rt(e,n),c=Mt(e,n),l=n.getURI()||n.getName()||`${s+1}/${e.getRoot().listTextures().length}`,g=`${o}:texture(${l})`;if(!zt.includes(n.getMimeType()))return void r.debug(`${g}: Skipping, unsupported texture type "${n.getMimeType()}".`);if(!t.formats.test(n.getMimeType()))return void r.debug(`${g}: Skipping, "${n.getMimeType()}" excluded by "formats" parameter.`);if(a.length&&!a.some(e=>t.slots.test(e)))return void r.debug(`${g}: Skipping, [${a.join(", ")}] excluded by "slots" parameter.`);if(t.codec===Nt.MOZJPEG&&c&d.A)return void r.warn(`${g}: Skipping, [${a.join(", ")}] requires alpha channel.`);r.debug(`${g}: Slots → [${a.join(", ")}]`);const u=i.ingestImage(n.getImage()),f=n.getImage().byteLength;await u.encode({[t.codec]:t.auto?"auto":{}});const p=await u.encodedWith[t.codec];r.debug(`${g}: ${JSON.stringify(p.optionsUsed)}`),n.setImage(p.binary).setMimeType(Ot[t.codec]);const m=p.binary.byteLength;r.debug(`${g}: ${V(f)} → ${V(m)}`)})),_t(),r.debug(`${o}: Complete.`)}},Gt=function(e){const t=B({},Pt,e);return async e=>{await kt(t)(e),e.getRoot().listTextures().some(e=>e.getMimeType()===Ot[Nt.WEBP])&&e.createExtension(R).setRequired(!0)}},Bt=function(e){const t=B({},xt,e);return e=>kt(t)(e)},Ft=function(e){const t=B({},$t,e);return e=>kt(t)(e)},Ut={overwrite:!1};function Wt(e=Ut){if(!e.generateTangents)throw new Error('tangents: generateTangents callback required — install "mikktspace".');const t=B({},Ut,e);return F("tangents",e=>{const n=e.getLogger(),o=new Map,r=new Map;let s=0;for(const i of e.getRoot().listMeshes()){const a=i.getName(),c=i.listPrimitives();for(let i=0;i<c.length;i++){const l=c[i];if(!Vt(l,n,a,i,t.overwrite))continue;const g=jt(l),u=l.getAttribute("POSITION").getArray(),f=l.getAttribute("NORMAL").getArray(),p=l.getAttribute(g).getArray(),m=o.get(u)||h();o.set(u,m);const d=o.get(f)||h();o.set(f,d);const A=o.get(p)||h();o.set(p,A);const y=l.getAttribute("TANGENT");y&&2===y.listParents().length&&y.dispose();const E=`${m}|${d}|${A}`;let T=r.get(E);if(T){n.debug(`tangents: Found cache for primitive ${i} of mesh "${a}".`),l.setAttribute("TANGENT",T),s++;continue}n.debug(`tangents: Generating for primitive ${i} of mesh "${a}".`);const S=l.getAttribute("POSITION").getBuffer(),I=t.generateTangents(u instanceof Float32Array?u:new Float32Array(u),f instanceof Float32Array?f:new Float32Array(f),p instanceof Float32Array?p:new Float32Array(p));for(let e=3;e<I.length;e+=4)I[e]*=-1;T=e.createAccessor().setBuffer(S).setArray(I).setType("VEC4"),l.setAttribute("TANGENT",T),r.set(E,T),s++}}s?n.debug("tangents: Complete."):n.warn("tangents: No qualifying primitives found. See debug output.")})}function jt(e){const t=e.getMaterial();if(!t)return"TEXCOORD_0";const n=t.getNormalTextureInfo();if(!n)return"TEXCOORD_0";const o=`TEXCOORD_${n.getTexCoord()}`;return e.getAttribute(o)?o:"TEXCOORD_0"}function Vt(t,n,o,r,s){return t.getMode()===e.Mode.TRIANGLES&&t.getAttribute("POSITION")&&t.getAttribute("NORMAL")&&t.getAttribute("TEXCOORD_0")?t.getAttribute("TANGENT")&&!s?(n.debug(`tangents: Skipping primitive ${r} of mesh "${o}": TANGENT found.`),!1):!t.getIndices()||(n.warn(`tangents: Skipping primitive ${r} of mesh "${o}": primitives must be unwelded.`),!1):(n.debug(`tangents: Skipping primitive ${r} of mesh "${o}": primitives must have attributes=[POSITION, NORMAL, TEXCOORD_0] and mode=TRIANGLES.`),!1)}const Ht="textureResize";var Dt;!function(e){e.LANCZOS3="lanczos3",e.LANCZOS2="lanczos2"}(Dt||(Dt={}));const Xt={size:[2048,2048],filter:Dt.LANCZOS3,pattern:null,slots:null};function Kt(e=Xt){const t=B({},Xt,e);return F(Ht,async e=>{const n=e.getLogger();for(const o of e.getRoot().listTextures()){const r=o.getName(),s=o.getURI();if(t.pattern&&!t.pattern.test(r)&&!t.pattern.test(s)){n.debug(`${Ht}: Skipping, excluded by "pattern" parameter.`);continue}if("image/png"!==o.getMimeType()&&"image/jpeg"!==o.getMimeType()){n.warn(`${Ht}: Skipping, unsupported texture type "${o.getMimeType()}".`);continue}const i=Rt(e,o);if(t.slots&&!i.some(e=>{var n;return null==(n=t.slots)?void 0:n.test(e)})){n.debug(`${Ht}: Skipping, [${i.join(", ")}] excluded by "slots" parameter.`);continue}const[a,c]=t.size,[l,g]=o.getSize();if(l<=a&&g<=c){n.debug(`${Ht}: Skipping, not within size range.`);continue}let u=l,f=g;u>a&&(f=Math.floor(f*(a/u)),u=a),f>c&&(u=Math.floor(u*(c/f)),f=c);const p=o.getImage(),m=await A(p,o.getMimeType()),d=_(new Uint8Array(u*f*4),[u,f,4]);n.debug(`${Ht}: Resizing "${s||r}", ${m.shape} → ${d.shape}...`),n.debug(`${Ht}: Slots → [${i.join(", ")}]`);try{t.filter===Dt.LANCZOS3?k(m,d):G(m,d)}catch(e){if(e instanceof Error){n.warn(`${Ht}: Failed to resize "${s||r}": "${e.message}".`);continue}throw e}o.setImage(await y(d,o.getMimeType()))}n.debug(`${Ht}: Complete.`)})}const Zt=()=>e=>{const t=e.createExtension(N).createUnlit();e.getRoot().listMaterials().forEach(e=>{e.setExtension("KHR_materials_unlit",t)})},Jt={},Qt=(e=Jt)=>(B({},Jt,e),F("unpartition",async e=>{const t=e.getLogger(),n=e.getRoot().listBuffers()[0];e.getRoot().listAccessors().forEach(e=>e.setBuffer(n)),e.getRoot().listBuffers().forEach((e,t)=>t>0?e.dispose():null),t.debug("unpartition: Complete.")}));export{le as DRACO_DEFAULTS,Xe as MESHOPT_DEFAULTS,qe as QUANTIZE_DEFAULTS,St as SIMPLIFY_DEFAULTS,Xt as TEXTURE_RESIZE_DEFAULTS,Dt as TextureResizeFilter,ft as WELD_DEFAULTS,Y as center,te as colorspace,Ce as createLayoutPlan,oe as dedup,ie as dequantize,ge as draco,Mt as getTextureChannelMask,ue as inspect,Ie as instance,wt as listTextureChannels,Rt as listTextureSlots,Ke as meshopt,Je as metalRough,Bt as mozjpeg,nt as normals,Ft as oxipng,st as partition,Re as prune,_e as quantize,Oe as reorder,ct as resample,ut as sequence,It as simplify,bt as simplifyPrimitive,kt as squoosh,Wt as tangents,Kt as textureResize,Zt as unlit,Qt as unpartition,Ye as unweld,Gt as webp,pt as weld};
//# sourceMappingURL=functions.modern.js.map
